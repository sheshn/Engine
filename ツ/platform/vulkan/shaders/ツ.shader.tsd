#define INVALID_MATERIAL_ID (1 << 15)

struct Material
{
    v4  base_color_factor;
    f32 metallic_factor;
    f32 roughness_factor;

    u32 albedo_texture_id;
    u32 normal_texture_id;
    u32 occlusion_roughness_metallic_texture_id;

    u32 reserved[7];
};

struct Transform
{
    m4x4 model;
};

struct Voxel_Data
{
    u32 color;
};

struct Frame_Uniforms
{
    m4x4 projection;
    m4x4 view_projection;
    m4x4 inverse_view_projection;

    v3  voxel_grid_origin;
    f32 voxel_grid_resolution;
    f32 voxel_size;
    f32 voxel_ray_step_size;

    v2  inverse_render_dimensions;
};

v3 depth_to_position(f32 depth, v2 uv, m4x4 projection, m4x4 inverse_view_projection)
{
    f32 linear_depth = projection[3][2] / (depth - projection[2][2]);
    v4 clip_space = v4(uv * 2 - 1, depth, 1);
    v4 world_space = inverse_view_projection * clip_space;
    return world_space.xyz / world_space.w;
}

layout Global_Layout
{
    layout(set = 0, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(set = 1, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 1, binding = 1) uniform texture2D textures_2d[];
    layout(set = 1, binding = 2) buffer material_buffer { Material materials[]; };
    layout(set = 1, binding = 3) buffer transform_buffer { Transform xforms[]; };

    layout(set = 1, binding = 4) uniform texture2D main_color_texture;
    layout(set = 1, binding = 5) uniform texture2D depth_attachment;

    layout(set = 1, binding = 6) buffer voxel_buffer { Voxel_Data voxels[]; };
    layout(set = 1, binding = 7, rgba8) uniform image3D voxel_image;
    layout(set = 1, binding = 8) uniform sampler3D voxel_texture;
};

struct Default_Vertex_In
{
    uv2 instance_data: [per_instance];

    v3 position;
    v3 normal;
    v4 tangent;
    v2 uv0;
};

struct Default_Fragment_In
{
    v4 vertex_position: [position];

    u32 material_id: [flat];

    v3 normal;
    v3 tangent;
    v3 bitangent;
    v2 uv0;
};

struct Default_Fragment_Out
{
    v4 color;
};

vertex(Global_Layout) Default_Fragment_In default_vertex_shader(Default_Vertex_In stage_in)
{
    Default_Fragment_In stage_out;
    stage_out.vertex_position = frame_uniforms.view_projection * xforms[stage_in.instance_data.x].model * v4(stage_in.position.xyz, 1.0);
    stage_out.material_id = stage_in.instance_data.y;
    stage_out.normal = normalize(m3x3(xforms[stage_in.instance_data.x].model) * stage_in.normal);
    stage_out.tangent = normalize(m3x3(xforms[stage_in.instance_data.x].model) * stage_in.tangent.xyz);
    stage_out.bitangent = cross(stage_out.normal, stage_out.tangent) * stage_in.tangent.w;
    stage_out.uv0 = stage_in.uv0;
    return stage_out;
}

fragment(Global_Layout) Default_Fragment_Out default_fragment_shader(Default_Fragment_In stage_in)
{
    Material material = materials[stage_in.material_id];
    v4 base_color = texture(sampler2D(textures_2d[nonuniformEXT(material.albedo_texture_id)], texture_2d_sampler), stage_in.uv0) * material.base_color_factor;
    v4 occlusion_roughness_metallic = texture(sampler2D(textures_2d[nonuniformEXT(material.occlusion_roughness_metallic_texture_id)], texture_2d_sampler), stage_in.uv0);
    f32 roughness = occlusion_roughness_metallic.g * material.roughness_factor;
    f32 metallic = occlusion_roughness_metallic.b * material.metallic_factor;

    v3 f0 = v3(0.04);
    v3 albedo = base_color.rgb * (v3(1) - f0);
    albedo *= 1 - metallic;

    roughness *= roughness;
    v3 specular = mix(f0, base_color.rgb, metallic);

    m3x3 tangent_frame_matrix = m3x3(normalize(stage_in.tangent), normalize(stage_in.bitangent), normalize(stage_in.normal));

    v2 normal = texture(sampler2D(textures_2d[nonuniformEXT(material.normal_texture_id)], texture_2d_sampler), stage_in.uv0).rg;
    v3 tangent_space_normal;
    tangent_space_normal.xy = normal * 2 - 1;
    tangent_space_normal.z = sqrt(1 - clamp(tangent_space_normal.x * tangent_space_normal.x + tangent_space_normal.y * tangent_space_normal.y, 0, 1));
    v3 world_space_normal = normalize(tangent_frame_matrix * tangent_space_normal);

    Default_Fragment_Out stage_out = {v4(specular.rgb, 1)};
    return stage_out;
}

struct Final_Pass_Fragment_In
{
    v4 vertex_position: [position];

    v2 uv;
};

struct Final_Pass_Fragment_Out
{
    v4 color;
};

vertex(Global_Layout) Final_Pass_Fragment_In final_pass_vertex_shader()
{
    Final_Pass_Fragment_In stage_out;
    stage_out.uv = v2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
    stage_out.vertex_position = v4(stage_out.uv * 2.0 - 1.0, 0, 1.0);
    return stage_out;
}

v3 aces_tonemap(v3 color)
{
    m3x3 aces_input_mat =
    {
        {0.59719, 0.35458, 0.04823},
        {0.07600, 0.90834, 0.01566},
        {0.02840, 0.13383, 0.83777}
    };
    m3x3 aces_output_mat =
    {
        { 1.60475, -0.53108, -0.07367},
        {-0.10208,  1.10813, -0.00605},
        {-0.00327, -0.07276,  1.07602}
    };

    color = color * aces_input_mat;
    color = ((color * (color + 0.0245786f) - 0.000090537f) / (color * (0.983729f * color + 0.4329510f) + 0.238081f)) * aces_output_mat;
    return clamp(color, 0, 1);
}

fragment(Global_Layout) Final_Pass_Fragment_Out final_pass_fragment_shader(Final_Pass_Fragment_In stage_in)
{
    v3 color = texture(sampler2D(main_color_texture, texture_2d_sampler), stage_in.uv).xyz;
    color *= 2; // TODO: Automatic exposure

    color = aces_tonemap(color);

    Final_Pass_Fragment_Out stage_out = {v4(color, 1)};
    return stage_out;
}

struct Voxelizer_Geometry_In
{
    v4 vertex_position: [position];

    u32 material_id: [flat];

    v3 normal;
    v2 uv0;
};

struct Voxelizer_Geometry_Out
{
    v4 vertex_position: [position];

    u32 material_id: [flat];

    v3 position;
    v3 normal;
    v2 uv0;
};

u32 index_3d_to_index_1d(uv3 index_3d, uv3 dimension)
{
    return (index_3d.z * dimension.x * dimension.y) + (index_3d.y * dimension.x) + index_3d.x;
}

uv3 index_1d_to_index_3d(u32 index, uv3 dimension)
{
    u32 z = index / (dimension.x * dimension.y);
    index -= (z * dimension.x * dimension.y);
    return uv3(index % dimension.x, index / dimension.y, z);
}

u32 encode_v4_color_as_u32(v4 color)
{
    // TODO: Tune this value
    f32 hdr_range = 10;
    f32 hdr = length(color.rgb);
    color.rgb /= hdr;

    uv3 c = uv3(color.rgb * 255.0);
    u32 h = u32(clamp(hdr / hdr_range, 0, 1) * 127.0);
    u32 a = color.a > 0 ? 1 : 0;

    return (h << 24) | (c.r << 16) | (c.g << 8) | (c.b) | (a << 31);
}

v4 decode_u32_color_as_v4(u32 color)
{
    // TODO: Tune this value
    f32 hdr_range = 10;
    f32 hdr = ((color >> 24) & 0x0000007F) / 127.0;

    v4 result = v4((color >> 16) & 0x000000FF, (color >> 8) & 0X000000FF, color & 0X000000FF, (color >> 31) & 0x00000001);
    result.rgb *= hdr * hdr_range / 255.0;
    return result;
}

vertex(Global_Layout) Voxelizer_Geometry_In voxelizer_vertex_shader(Default_Vertex_In stage_in)
{
    Voxelizer_Geometry_In stage_out;
    stage_out.vertex_position = xforms[stage_in.instance_data.x].model * v4(stage_in.position.xyz, 1.0);
    stage_out.material_id = stage_in.instance_data.y;
    stage_out.normal = normalize(m3x3(xforms[stage_in.instance_data.x].model) * stage_in.normal);
    stage_out.uv0 = stage_in.uv0;
    return stage_out;
}

geometry(Global_Layout) Voxelizer_Geometry_Out[3] voxelizer_geometry_shader(Voxelizer_Geometry_In stage_in[3])
{
    v3 normal = abs(stage_in[0].normal + stage_in[1].normal + stage_in[2].normal);
    u32 max_index = normal.y > normal.x ? 1 : 0;
    max_index = normal.z > normal[max_index] ? 2 : max_index;

    v3 positions[3];
    for (u32 i = 0; i < 3; ++i)
    {
        positions[i] = (gl_in[i].gl_Position.xyz - frame_uniforms.voxel_grid_origin) / frame_uniforms.voxel_size;
        if (max_index == 0)
        {
            positions[i].xyz = positions[i].zyx;
        }
        else if (max_index == 1)
        {
            positions[i].xyz = positions[i].xzy;
        }
    }

    // NOTE: Enlarge triangle to achieve conservative rasterization
    v2 s0 = normalize(positions[1].xy - positions[0].xy);
    v2 s1 = normalize(positions[2].xy - positions[1].xy);
    v2 s2 = normalize(positions[0].xy - positions[2].xy);
    positions[0].xy += normalize(s2 - s0);
    positions[1].xy += normalize(s0 - s1);
    positions[2].xy += normalize(s1 - s2);

    Voxelizer_Geometry_Out stage_out[3];
    for (u32 i = 0; i < 3; ++i)
    {
        stage_out[i].material_id = stage_in[i].material_id;
        stage_out[i].position = gl_in[i].gl_Position.xyz;
        stage_out[i].normal = stage_in[i].normal;
        stage_out[i].uv0 = stage_in[i].uv0;

        stage_out[i].vertex_position = v4(positions[i].xy / frame_uniforms.voxel_grid_resolution, 1, 1);
    }
    return stage_out;
}

fragment(Global_Layout) void voxelizer_fragment_shader(Voxelizer_Geometry_Out stage_in)
{
    v3 uvw = 0.5 * ((stage_in.position - frame_uniforms.voxel_grid_origin) / frame_uniforms.voxel_grid_resolution / frame_uniforms.voxel_size) + 0.5f;
    if (uvw == clamp(uvw, 0, 1))
    {
        Material material = materials[stage_in.material_id];
        v4 color = texture(sampler2D(textures_2d[material.albedo_texture_id], texture_2d_sampler), stage_in.uv0) * material.base_color_factor;
        u32 encoded_color = encode_v4_color_as_u32(color);

        u32 index = index_3d_to_index_1d(uv3(floor(uvw * frame_uniforms.voxel_grid_resolution)), uv3(frame_uniforms.voxel_grid_resolution));
        atomicMax(voxels[index].color, encoded_color);
    }
}

layout Voxelizer_Compute_Layout
{
    layout (local_size_x = 256) in;
};

compute(Global_Layout, Voxelizer_Compute_Layout) void voxelizer_compute_shader()
{
    uv3 uvw = index_1d_to_index_3d(gl_GlobalInvocationID.x, uv3(frame_uniforms.voxel_grid_resolution));
    v4 color = decode_u32_color_as_v4(voxels[gl_GlobalInvocationID.x].color);

    if (color.a > 0)
    {
        // TODO: Smooth from prevous data if the voxel grid origin moved?
        imageStore(voxel_image, sv3(uvw), color);
    }
    else
    {
        imageStore(voxel_image, sv3(uvw), v4(0));
    }

    voxels[gl_GlobalInvocationID.x].color = 0;
}

struct DEBUG_Voxel_Visualizer_Geometry_In
{
    v4 vertex_position: [position];

    v4 color;
};

struct DEBUG_Voxel_Visualizer_Fragment_Out
{
    v4 color;
};

vertex(Global_Layout) DEBUG_Voxel_Visualizer_Geometry_In DEBUG_voxel_visualizer_vertex_shader()
{
    uv3 uvw = index_1d_to_index_3d(gl_VertexIndex, uv3(frame_uniforms.voxel_grid_resolution));

    DEBUG_Voxel_Visualizer_Geometry_In stage_out;
    stage_out.vertex_position = v4(uvw, 1);
    stage_out.color = textureLod(voxel_texture, v3(uvw) / frame_uniforms.voxel_grid_resolution, 0);
    return stage_out;
}

geometry(Global_Layout) DEBUG_Voxel_Visualizer_Geometry_In[14] DEBUG_voxel_visualizer_geometry_shader(DEBUG_Voxel_Visualizer_Geometry_In stage_in[1])
{
    if (stage_in[0].color.a > 0)
    {
        DEBUG_Voxel_Visualizer_Geometry_In stage_out[14];
        for (u32 i = 0; i < 14; ++i)
        {
            stage_out[i].color = stage_in[0].color;
            stage_out[i].vertex_position.xyz = (gl_in[0].gl_Position.xyz / frame_uniforms.voxel_grid_resolution * 2 - 1) * frame_uniforms.voxel_grid_resolution;

            // NOTE: Cube vertex position from index
            stage_out[i].vertex_position.xyz += (v3((0x287A & (1 << i)) != 0, (0x02AF & (1 << i)) != 0, (0x31E3 & (1 << i)) != 0) - v3(0, 1, 0)) * 2;

            stage_out[i].vertex_position.xyz *= frame_uniforms.voxel_grid_resolution * frame_uniforms.voxel_size / frame_uniforms.voxel_grid_resolution;
            stage_out[i].vertex_position = frame_uniforms.view_projection * v4(stage_out[i].vertex_position.xyz + frame_uniforms.voxel_grid_origin, 1);
        }
        return stage_out;
    }
}

fragment(Global_Layout) DEBUG_Voxel_Visualizer_Fragment_Out DEBUG_voxel_visualizer_fragment_shader(DEBUG_Voxel_Visualizer_Geometry_In stage_in)
{
    DEBUG_Voxel_Visualizer_Fragment_Out stage_out = {v4(stage_in.color.rgb, 1)};
    return stage_out;
}

pipeline Gbuffer_Pipeline
{
    shaders = [default_vertex_shader, default_fragment_shader];

    rasterization_state = {
        cull_mode  = VK_CULL_MODE_FRONT_BIT,
        front_face = VK_FRONT_FACE_COUNTER_CLOCKWISE
    };

    color_blend_state = [
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT}
    ];

    depth_stencil_state = {
        depth_test_enable  = VK_TRUE,
        depth_write_enable = VK_TRUE,
        depth_compare_op   = VK_COMPARE_OP_GREATER_OR_EQUAL
    };
};

pipeline Final_Pass_Pipeline
{
    shaders = [final_pass_vertex_shader, final_pass_fragment_shader];

    rasterization_state = {
        cull_mode  = VK_CULL_MODE_FRONT_BIT,
        front_face = VK_FRONT_FACE_COUNTER_CLOCKWISE
    };

    color_blend_state = [
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT}
    ];
};

pipeline Voxelizer_Pipeline
{
    shaders = [voxelizer_vertex_shader, voxelizer_geometry_shader, voxelizer_fragment_shader];
};

pipeline Voxelizer_Compute_Pipeline
{
    shaders = [voxelizer_compute_shader];
};

pipeline DEBUG_Voxel_Visualizer_Pipeline
{
    shaders = [DEBUG_voxel_visualizer_vertex_shader, DEBUG_voxel_visualizer_geometry_shader, DEBUG_voxel_visualizer_fragment_shader];

    input_assembly_state = {
        topology = VK_PRIMITIVE_TOPOLOGY_POINT_LIST
    };

    color_blend_state = [
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT}
    ];
};