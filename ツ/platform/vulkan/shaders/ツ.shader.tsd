#define INVALID_MATERIAL_ID (1 << 15)

#define Dispatch_Indirect_Command uv3

struct Material
{
    v4  base_color_factor;
    f32 metallic_factor;
    f32 roughness_factor;

    u32 albedo_texture_id;
    u32 normal_texture_id;
    u32 occlusion_roughness_metallic_texture_id;

    u32 reserved[7];
};

struct Transform
{
    m4x4 model;
};

struct Voxel_Data
{
    u32 color;
};

struct Cluster_AABB
{
    v4 min;
    v4 max;
};

struct Cluster_Light_Info
{
    u32 offset;
    u32 count;
};

#define MAX_LIGHTS_PER_CLUSTER 64
#define LIGHT_TYPE_DIRECTIONAL 0
#define LIGHT_TYPE_POINT       1
#define LIGHT_TYPE_SPOT        2

struct Light
{
    u32 type;
    u32 reserved[3];

    v4 position_or_direction_radius;
    v4 color_intensity;
};

struct Frame_Uniforms
{
    m4x4 view;
    m4x4 projection;
    m4x4 view_projection;
    m4x4 inverse_projection;
    m4x4 inverse_view_projection;

    m4x4 DEBUG_view;

    v4  camera_position;
    v4  voxel_grid_origin_resolution;
    uv4 cluster_grid_resolution_size;
    v4  cluster_grid_near_far_scale_bias;

    v2 inverse_render_dimensions;

    f32 voxel_size;
    f32 voxel_ray_step_size;

    u32 light_count;
};

u32 index_3d_to_index_1d(uv3 index_3d, uv3 dimension)
{
    return (index_3d.z * dimension.x * dimension.y) + (index_3d.y * dimension.x) + index_3d.x;
}

uv3 index_1d_to_index_3d(u32 index, uv3 dimension)
{
    u32 z = index / (dimension.x * dimension.y);
    index -= (z * dimension.x * dimension.y);
    return uv3(index % dimension.x, index / dimension.y, z);
}

v4 screen_to_view_space(v4 screen_space, v2 inverse_screen_dimensions, m4x4 inverse_projection)
{
    v2 uv = screen_space.xy * inverse_screen_dimensions;
    v4 clip_space = v4(uv * 2 - 1, screen_space.z, screen_space.w);
    v4 view_space = inverse_projection * clip_space;
    return view_space / view_space.w;
}

f32 linear_depth(f32 depth, m4x4 projection)
{
    return projection[3][2] / (depth - projection[2][2]);
}

v3 depth_to_position(f32 depth, v2 uv, m4x4 projection, m4x4 inverse_view_projection)
{
    f32 linear_depth = projection[3][2] / (depth - projection[2][2]);
    v4 clip_space = v4(uv * 2 - 1, depth, 1);
    v4 world_space = inverse_view_projection * clip_space;
    return world_space.xyz / world_space.w;
}

layout Global_Layout
{
    layout(set = 0, binding = 0, std140) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };
    layout(set = 0, binding = 1, std430) buffer light_buffer { Light lights[]; };

    layout(set = 1, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 1, binding = 1) uniform texture2D textures_2d[];
    layout(set = 1, binding = 2, std430) buffer material_buffer { Material materials[]; };
    layout(set = 1, binding = 3, std430) buffer transform_buffer { Transform xforms[]; };

    layout(set = 1, binding = 4) uniform texture2D main_color_texture;
    layout(set = 1, binding = 5) uniform texture2D depth_attachment;

    layout(set = 1, binding = 6, std430) buffer voxel_buffer { Voxel_Data voxels[]; };
    layout(set = 1, binding = 7, rgba8) uniform image3D voxel_image;
    layout(set = 1, binding = 8) uniform sampler3D voxel_texture;

    layout(set = 1, binding = 9, std430) buffer cluster_aabb_buffer { Cluster_AABB cluster_aabbs[]; };
    layout(set = 1, binding = 10, std430) buffer active_clusters_buffer { u32 active_clusters[]; };
    layout(set = 1, binding = 11, std430) buffer unique_clusters_buffer { Dispatch_Indirect_Command unique_clusters_dispatch_command; u32 unique_clusters[]; };
    layout(set = 1, binding = 12, std430) buffer cluster_light_index_buffer { u32 cluster_light_index_list_counter; u32 cluster_light_index_list[]; };
    layout(set = 1, binding = 13, std430) buffer cluster_light_info_buffer { Cluster_Light_Info cluster_light_info[]; };
};

struct Full_Screen_Triangle_Fragment_In
{
    v4 vertex_position: [position];

    v2 uv;
};

vertex(Global_Layout) Full_Screen_Triangle_Fragment_In full_screen_triangle_vertex_shader()
{
    Full_Screen_Triangle_Fragment_In stage_out;
    stage_out.uv = v2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
    stage_out.vertex_position = v4(stage_out.uv * 2.0 - 1.0, 0, 1.0);
    return stage_out;
}

v3 line_to_z_plane_intersection(v3 a, v3 b, f32 z)
{
    v3 normal = v3(0, 0, 1);
    v3 ab = b - a;

    f32 t = (z - dot(normal, a)) / dot(normal, ab);
    return a + t * ab;
}

compute(Global_Layout) void clusterizer_shader()
{
    v4 screen_space_aabb_max = v4(v2(gl_GlobalInvocationID.x + 1, gl_GlobalInvocationID.y + 1) * frame_uniforms.cluster_grid_resolution_size.w, 1, 1);
    v4 screen_space_aabb_min = v4(gl_GlobalInvocationID.xy * frame_uniforms.cluster_grid_resolution_size.w, 1, 1);

    v3 view_space_aabb_max = screen_to_view_space(screen_space_aabb_max, frame_uniforms.inverse_render_dimensions, frame_uniforms.inverse_projection).xyz;
    v3 view_space_aabb_min = screen_to_view_space(screen_space_aabb_min, frame_uniforms.inverse_render_dimensions, frame_uniforms.inverse_projection).xyz;

    f32 cluster_near = frame_uniforms.cluster_grid_near_far_scale_bias.x * pow(frame_uniforms.cluster_grid_near_far_scale_bias.y / frame_uniforms.cluster_grid_near_far_scale_bias.x, gl_GlobalInvocationID.z / f32(frame_uniforms.cluster_grid_resolution_size.z));
    f32 cluster_far = frame_uniforms.cluster_grid_near_far_scale_bias.x * pow(frame_uniforms.cluster_grid_near_far_scale_bias.y / frame_uniforms.cluster_grid_near_far_scale_bias.x, (gl_GlobalInvocationID.z + 1) / f32(frame_uniforms.cluster_grid_resolution_size.z));

    v3 max_near = line_to_z_plane_intersection(v3(0), view_space_aabb_max, cluster_near);
    v3 max_far = line_to_z_plane_intersection(v3(0), view_space_aabb_max, cluster_far);
    v3 min_near = line_to_z_plane_intersection(v3(0), view_space_aabb_min, cluster_near);
    v3 min_far = line_to_z_plane_intersection(v3(0), view_space_aabb_min, cluster_far);

    vec3 aabb_max = max(max(min_near, min_far), max(max_near, max_far));
    vec3 aabb_min = min(min(min_near, min_far), min(max_near, max_far));

    u32 cluster_index = index_3d_to_index_1d(gl_GlobalInvocationID, frame_uniforms.cluster_grid_resolution_size.xyz);
    cluster_aabbs[cluster_index].max = v4(aabb_max, 0);
    cluster_aabbs[cluster_index].min = v4(aabb_min, 0);
}

struct Default_Vertex_In
{
    uv2 instance_data: [per_instance];

    v3 position;
    v3 normal;
    v4 tangent;
    v2 uv0;
};

struct Default_Fragment_In
{
    v4 vertex_position: [position];

    u32 material_id: [flat];

    v3 position;
    v3 normal;
    v3 tangent;
    v3 bitangent;
    v2 uv0;
};

struct Default_Fragment_Out
{
    v4 color;
};

struct Depth_Only_Vertex_Out
{
    v4 vertex_position: [position];
};

vertex(Global_Layout) Depth_Only_Vertex_Out depth_only_vertex_shader(Default_Vertex_In stage_in)
{
    Depth_Only_Vertex_Out stage_out = {frame_uniforms.view_projection * xforms[stage_in.instance_data.x].model * v4(stage_in.position.xyz, 1.0)};
    return stage_out;
}

fragment(Global_Layout) void update_active_clusters_shader(Full_Screen_Triangle_Fragment_In stage_in)
{
    f32 depth = texelFetch(depth_attachment, sv2(gl_FragCoord.xy), 0).r;
    u32 cluster_z = u32(max(log2(linear_depth(depth, frame_uniforms.projection)) * frame_uniforms.cluster_grid_near_far_scale_bias.z + frame_uniforms.cluster_grid_near_far_scale_bias.w, 0));
    if (cluster_z < frame_uniforms.cluster_grid_resolution_size.z)
    {
        uv3 cluster_coordinate = uv3(uv2(gl_FragCoord.xy / frame_uniforms.cluster_grid_resolution_size.w), cluster_z);
        u32 cluster_index = index_3d_to_index_1d(cluster_coordinate, frame_uniforms.cluster_grid_resolution_size.xyz);

        active_clusters[cluster_index] = 1;
    }
}

layout Update_Unique_Clusters_Layout
{
    layout(local_size_x = 1024) in;
};

compute(Global_Layout, Update_Unique_Clusters_Layout) void update_unique_clusters_shader()
{
    u32 cluster_index = gl_GlobalInvocationID.x;
    if (cluster_index < frame_uniforms.cluster_grid_resolution_size.x * frame_uniforms.cluster_grid_resolution_size.y * frame_uniforms.cluster_grid_resolution_size.z && active_clusters[cluster_index] == 1)
    {
        u32 index = atomicAdd(unique_clusters_dispatch_command.x, 1);
        unique_clusters[index] = cluster_index;

        // NOTE: Reset active clusters for next frame, cluster light infos for this frame
        active_clusters[index] = 0;
        cluster_light_info[cluster_index].count = 0;
    }
}

bool sphere_intersects_aabb(v3 sphere_center, f32 sphere_radius, v3 aabb_min, v3 aabb_max)
{
    f32 squared_distance = 0;
    for (u32 i = 0; i < 3; ++i)
    {
        f32 p = sphere_center[i];
        if (p < aabb_min[i])
        {
            squared_distance += (aabb_min[i] - p) * (aabb_min[i] - p);
        }
        if (p > aabb_max[i])
        {
            squared_distance += (p - aabb_max[i]) * (p - aabb_max[i]);
        }
    }
    return squared_distance <= (sphere_radius * sphere_radius);
}

layout Cluster_Light_Culling_Compute_Layout
{
    layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
};

compute(Global_Layout, Cluster_Light_Culling_Compute_Layout) void cluster_light_culling_shader()
{
    // TODO: Use shared memory to load the lights
    u32 cluster_index = unique_clusters[gl_GlobalInvocationID.x];
    Cluster_AABB cluster_aabb = cluster_aabbs[cluster_index];

    u32 visible_light_count = 0;
    u32 visible_light_index_list[MAX_LIGHTS_PER_CLUSTER];

    for (u32 i = 0; i < frame_uniforms.light_count; ++i)
    {
        v3 view_space_light_position = (frame_uniforms.view * v4(lights[i].position_or_direction_radius.xyz, 1)).xyz;
        if (lights[i].type == LIGHT_TYPE_POINT && sphere_intersects_aabb(view_space_light_position, lights[i].position_or_direction_radius.w, cluster_aabb.min.xyz, cluster_aabb.max.xyz))
        {
            visible_light_index_list[visible_light_count++] = i;
        }
    }

    u32 light_index_list_offset = atomicAdd(cluster_light_index_list_counter, visible_light_count);
    for (u32 i = 0; i < visible_light_count; ++i)
    {
        cluster_light_index_list[light_index_list_offset + i] = visible_light_index_list[i];
    }

    cluster_light_info[cluster_index].offset = light_index_list_offset;
    cluster_light_info[cluster_index].count = visible_light_count;
}

vertex(Global_Layout) Default_Fragment_In default_vertex_shader(Default_Vertex_In stage_in)
{
    Default_Fragment_In stage_out;
    stage_out.vertex_position = frame_uniforms.view_projection * xforms[stage_in.instance_data.x].model * v4(stage_in.position.xyz, 1.0);
    stage_out.material_id = stage_in.instance_data.y;
    stage_out.position = (xforms[stage_in.instance_data.x].model * v4(stage_in.position.xyz, 1.0)).xyz;
    stage_out.normal = normalize(m3x3(xforms[stage_in.instance_data.x].model) * stage_in.normal);
    stage_out.tangent = normalize(m3x3(xforms[stage_in.instance_data.x].model) * stage_in.tangent.xyz);
    stage_out.bitangent = cross(stage_out.normal, stage_out.tangent) * stage_in.tangent.w;
    stage_out.uv0 = stage_in.uv0;
    return stage_out;
}

v3 diffuse(v3 albedo)
{
    return albedo / PI;
}

f32 microfacet_distribution(f32 alpha, f32 n_dot_h)
{
    f32 alpha_squared = alpha * alpha;
    f32 f = (n_dot_h * alpha_squared - n_dot_h) * n_dot_h + 1;
    return alpha_squared / (PI * f * f);
}

f32 geometric_occlusion(f32 alpha, f32 n_dot_l, f32 n_dot_v)
{
    f32 l = 2 * n_dot_l / (n_dot_l + sqrt(alpha * alpha + (1 - alpha * alpha) * (n_dot_l * n_dot_l)));
    f32 v = 2 * n_dot_v / (n_dot_v + sqrt(alpha * alpha + (1 - alpha * alpha) * (n_dot_v * n_dot_v)));
    return l * v;
}

v3 specular_reflection(v3 reflectance0, v3 reflectance90, f32 v_dot_h)
{
    return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1 - v_dot_h, 0, 1), 5);
}

v3 brdf(v3 light_direction, v3 surface_position, v3 surface_normal, v3 view_direction, v3 albedo, v3 specular, v3 reflectance90, f32 roughness)
{
    v3 l = normalize(light_direction);
    v3 h = normalize(l + view_direction);
    f32 n_dot_l = clamp(dot(surface_normal, l), 0.001, 1);
    f32 n_dot_v = clamp(abs(dot(surface_normal, view_direction)), 0.001, 1);
    f32 n_dot_h = clamp(dot(surface_normal, h), 0, 1);
    f32 v_dot_h = clamp(dot(view_direction, h), 0, 1);

    f32 D = microfacet_distribution(roughness, n_dot_h);
    f32 G = geometric_occlusion(roughness, n_dot_l, n_dot_v);
    v3 F = specular_reflection(specular, reflectance90, v_dot_h);

    v3 diffuse_contribution = (1 - F) * diffuse(albedo);
    v3 specular_contribution = F * G * D / (4 * n_dot_l * n_dot_v);
    return n_dot_l * (diffuse_contribution + specular_contribution);
}

v3 calculate_point_light(Light light, v3 surface_position, v3 surface_normal, v3 view_direction, v3 albedo, v3 specular, v3 reflectance90, f32 roughness)
{
    v3 surface_to_light = light.position_or_direction_radius.xyz - surface_position;
    f32 distance = length(surface_to_light);
    f32 attenuation = pow(clamp(1 - pow((distance / light.position_or_direction_radius.w), 4.0), 0.0, 1.0), 2.0)/(1.0  + (distance * distance));

    return light.color_intensity.rgb * light.color_intensity.w * attenuation * brdf(surface_to_light, surface_position, surface_normal, view_direction, albedo, specular, reflectance90, roughness);
}

layout Default_Fragment_Layout
{
    layout(early_fragment_tests) in;
};

fragment(Global_Layout, Default_Fragment_Layout) Default_Fragment_Out default_fragment_shader(Default_Fragment_In stage_in)
{
    Material material = materials[stage_in.material_id];
    v4 base_color = texture(sampler2D(textures_2d[material.albedo_texture_id], texture_2d_sampler), stage_in.uv0) * material.base_color_factor;
    v4 occlusion_roughness_metallic = texture(sampler2D(textures_2d[material.occlusion_roughness_metallic_texture_id], texture_2d_sampler), stage_in.uv0);
    f32 roughness = occlusion_roughness_metallic.g * material.roughness_factor;
    f32 metallic = occlusion_roughness_metallic.b * material.metallic_factor;

    v3 f0 = v3(0.04);
    v3 albedo = base_color.rgb * (v3(1) - f0);
    albedo *= 1 - metallic;

    roughness *= roughness;
    v3 specular = mix(f0, base_color.rgb, metallic);
    v3 reflectance90 = vec3(1) * clamp(max(max(specular.r, specular.g), specular.b) * 25, 0, 1);

    m3x3 tangent_frame_matrix = m3x3(normalize(stage_in.tangent), normalize(stage_in.bitangent), normalize(stage_in.normal));

    // TODO: If the model does not have a normal map, it will fetch texture 0 which is a white bitmap. This corresponds to a normal of (1, 1, 1) which is incorrect!
    v2 normal = texture(sampler2D(textures_2d[material.normal_texture_id], texture_2d_sampler), stage_in.uv0).rg;
    v3 tangent_space_normal;
    tangent_space_normal.xy = normal * 2 - 1;
    tangent_space_normal.z = sqrt(1 - clamp(tangent_space_normal.x * tangent_space_normal.x + tangent_space_normal.y * tangent_space_normal.y, 0, 1));
    v3 world_space_normal = normalize(tangent_frame_matrix * tangent_space_normal);

    v3 view_direction = normalize(frame_uniforms.camera_position.xyz - stage_in.position);
    v3 direct_lighting = v3(0);

    u32 cluster_z = u32(max(log2(linear_depth(gl_FragCoord.z, frame_uniforms.projection)) * frame_uniforms.cluster_grid_near_far_scale_bias.z + frame_uniforms.cluster_grid_near_far_scale_bias.w, 0));
    uv3 cluster_coordinate = uv3(uv2(gl_FragCoord.xy / frame_uniforms.cluster_grid_resolution_size.w), cluster_z);
    u32 cluster_index = index_3d_to_index_1d(cluster_coordinate, frame_uniforms.cluster_grid_resolution_size.xyz);

    u32 light_count = cluster_light_info[cluster_index].count;
    u32 light_offset = cluster_light_info[cluster_index].offset;
    for (u32 i = 0; i < light_count; ++i)
    {
        Light light = lights[cluster_light_index_list[light_offset + i]];
        direct_lighting += calculate_point_light(light, stage_in.position, world_space_normal, view_direction, albedo, specular, reflectance90, roughness);
    }

    Default_Fragment_Out stage_out = {v4(direct_lighting, 1)};
    return stage_out;
}

struct Final_Pass_Fragment_Out
{
    v4 color;
};

v3 aces_tonemap(v3 color)
{
    m3x3 aces_input_mat =
    {
        {0.59719, 0.35458, 0.04823},
        {0.07600, 0.90834, 0.01566},
        {0.02840, 0.13383, 0.83777}
    };
    m3x3 aces_output_mat =
    {
        { 1.60475, -0.53108, -0.07367},
        {-0.10208,  1.10813, -0.00605},
        {-0.00327, -0.07276,  1.07602}
    };

    color = color * aces_input_mat;
    color = ((color * (color + 0.0245786f) - 0.000090537f) / (color * (0.983729f * color + 0.4329510f) + 0.238081f)) * aces_output_mat;
    return clamp(color, 0, 1);
}

fragment(Global_Layout) Final_Pass_Fragment_Out final_pass_fragment_shader(Full_Screen_Triangle_Fragment_In stage_in)
{
    v3 color = texture(sampler2D(main_color_texture, texture_2d_sampler), stage_in.uv).xyz;
    color *= 2; // TODO: Automatic exposure

    color = aces_tonemap(color);

    Final_Pass_Fragment_Out stage_out = {v4(color, 1)};
    return stage_out;
}

struct Voxelizer_Geometry_In
{
    v4 vertex_position: [position];

    u32 material_id: [flat];

    v3 normal;
    v2 uv0;
};

struct Voxelizer_Geometry_Out
{
    v4 vertex_position: [position];

    u32 material_id: [flat];

    v3 position;
    v3 normal;
    v2 uv0;
};

u32 encode_v4_color_as_u32(v4 color)
{
    // TODO: Tune this value
    f32 hdr_range = 10;
    f32 hdr = length(color.rgb);
    color.rgb /= hdr;

    uv3 c = uv3(color.rgb * 255.0);
    u32 h = u32(clamp(hdr / hdr_range, 0, 1) * 127.0);
    u32 a = color.a > 0 ? 1 : 0;

    return (h << 24) | (c.r << 16) | (c.g << 8) | (c.b) | (a << 31);
}

v4 decode_u32_color_as_v4(u32 color)
{
    // TODO: Tune this value
    f32 hdr_range = 10;
    f32 hdr = ((color >> 24) & 0x0000007F) / 127.0;

    v4 result = v4((color >> 16) & 0x000000FF, (color >> 8) & 0X000000FF, color & 0X000000FF, (color >> 31) & 0x00000001);
    result.rgb *= hdr * hdr_range / 255.0;
    return result;
}

vertex(Global_Layout) Voxelizer_Geometry_In voxelizer_vertex_shader(Default_Vertex_In stage_in)
{
    Voxelizer_Geometry_In stage_out;
    stage_out.vertex_position = xforms[stage_in.instance_data.x].model * v4(stage_in.position.xyz, 1.0);
    stage_out.material_id = stage_in.instance_data.y;
    stage_out.normal = normalize(m3x3(xforms[stage_in.instance_data.x].model) * stage_in.normal);
    stage_out.uv0 = stage_in.uv0;
    return stage_out;
}

geometry(Global_Layout) Voxelizer_Geometry_Out[3] voxelizer_geometry_shader(Voxelizer_Geometry_In stage_in[3])
{
    v3 normal = abs(stage_in[0].normal + stage_in[1].normal + stage_in[2].normal);
    u32 max_index = normal.y > normal.x ? 1 : 0;
    max_index = normal.z > normal[max_index] ? 2 : max_index;

    v3 positions[3];
    for (u32 i = 0; i < 3; ++i)
    {
        positions[i] = (gl_in[i].gl_Position.xyz - frame_uniforms.voxel_grid_origin_resolution.xyz) / frame_uniforms.voxel_size;
        if (max_index == 0)
        {
            positions[i].xyz = positions[i].zyx;
        }
        else if (max_index == 1)
        {
            positions[i].xyz = positions[i].xzy;
        }
    }

    // NOTE: Enlarge triangle to achieve conservative rasterization
    v2 s0 = normalize(positions[1].xy - positions[0].xy);
    v2 s1 = normalize(positions[2].xy - positions[1].xy);
    v2 s2 = normalize(positions[0].xy - positions[2].xy);
    positions[0].xy += normalize(s2 - s0);
    positions[1].xy += normalize(s0 - s1);
    positions[2].xy += normalize(s1 - s2);

    Voxelizer_Geometry_Out stage_out[3];
    for (u32 i = 0; i < 3; ++i)
    {
        stage_out[i].material_id = stage_in[i].material_id;
        stage_out[i].position = gl_in[i].gl_Position.xyz;
        stage_out[i].normal = stage_in[i].normal;
        stage_out[i].uv0 = stage_in[i].uv0;

        stage_out[i].vertex_position = v4(positions[i].xy / frame_uniforms.voxel_grid_origin_resolution.w, 1, 1);
    }
    return stage_out;
}

fragment(Global_Layout) void voxelizer_fragment_shader(Voxelizer_Geometry_Out stage_in)
{
    v3 uvw = 0.5 * ((stage_in.position - frame_uniforms.voxel_grid_origin_resolution.xyz) / frame_uniforms.voxel_grid_origin_resolution.w / frame_uniforms.voxel_size) + 0.5f;
    if (uvw == clamp(uvw, 0, 1))
    {
        Material material = materials[stage_in.material_id];
        v4 color = texture(sampler2D(textures_2d[material.albedo_texture_id], texture_2d_sampler), stage_in.uv0) * material.base_color_factor;
        u32 encoded_color = encode_v4_color_as_u32(color);

        u32 index = index_3d_to_index_1d(uv3(floor(uvw * frame_uniforms.voxel_grid_origin_resolution.w)), uv3(frame_uniforms.voxel_grid_origin_resolution.w));
        atomicMax(voxels[index].color, encoded_color);
    }
}

layout Voxelizer_Compute_Layout
{
    layout (local_size_x = 256) in;
};

compute(Global_Layout, Voxelizer_Compute_Layout) void voxelizer_compute_shader()
{
    uv3 uvw = index_1d_to_index_3d(gl_GlobalInvocationID.x, uv3(frame_uniforms.voxel_grid_origin_resolution.w));
    v4 color = decode_u32_color_as_v4(voxels[gl_GlobalInvocationID.x].color);

    if (color.a > 0)
    {
        // TODO: Smooth from prevous data if the voxel grid origin moved?
        imageStore(voxel_image, sv3(uvw), color);
    }
    else
    {
        imageStore(voxel_image, sv3(uvw), v4(0));
    }

    voxels[gl_GlobalInvocationID.x].color = 0;
}

struct DEBUG_Cluster_Visualizer_Geometry_In
{
    v4 vertex_position: [position];

    u32 cluster_id: [flat];
};

struct DEBUG_Voxel_Visualizer_Geometry_In
{
    v4 vertex_position: [position];

    v4 color;
};

struct DEBUG_Voxel_Visualizer_Fragment_Out
{
    v4 color;
};

vertex(Global_Layout) DEBUG_Cluster_Visualizer_Geometry_In DEBUG_cluster_visualizer_vertex_shader()
{
    DEBUG_Cluster_Visualizer_Geometry_In stage_out;
    stage_out.cluster_id = gl_VertexIndex;
    return stage_out;
}

geometry(Global_Layout) DEBUG_Voxel_Visualizer_Geometry_In[14] DEBUG_cluster_visualizer_geometry_shader(DEBUG_Cluster_Visualizer_Geometry_In stage_in[1])
{
    Cluster_AABB cluster = cluster_aabbs[stage_in[0].cluster_id];
    v3 cluster_scale = abs(cluster.max - cluster.min).xyz;
    v3 cluster_position = cluster.min.xyz;
    u32 cluster_z = u32(max(log2(cluster_position.z) * frame_uniforms.cluster_grid_near_far_scale_bias.z + frame_uniforms.cluster_grid_near_far_scale_bias.w, 0));

    v3 DEBUG_cluster_colors[24] = v3[]
    (
        v3(143,0,255),   v3(227,38,54),   v3(77,93,83),    v3(102,221,170), v3(179,27,27),  v3(120,134,107),
        v3(193,154,107), v3(171,205,239), v3(240,220,130), v3(229,170,112), v3(105,53,156), v3(35,41,122),
        v3(210,105,30),  v3(216,191,216), v3(244,194,194), v3(209,226,49),  v3(255,127,80), v3(228,208,10),
        v3(250,214,165), v3(102,221,170), v3(161,202,241), v3(254,78,218),  v3(138,43,226), v3(112,41,99)
    );

    DEBUG_Voxel_Visualizer_Geometry_In stage_out[14];
    for (u32 i = 0; i < 14; ++i)
    {
        // NOTE: Cube vertex position from index
        stage_out[i].vertex_position.xyz = (v3((0x287A & (1 << i)) != 0, (0x02AF & (1 << i)) != 0, (0x31E3 & (1 << i)) != 0));
        stage_out[i].vertex_position = frame_uniforms.view_projection * frame_uniforms.DEBUG_view * v4(stage_out[i].vertex_position.xyz * cluster_scale + cluster_position, 1);
        stage_out[i].color = v4(DEBUG_cluster_colors[cluster_z] / 255.0, 1);
    }
    return stage_out;
}

vertex(Global_Layout) DEBUG_Voxel_Visualizer_Geometry_In DEBUG_voxel_visualizer_vertex_shader()
{
    uv3 uvw = index_1d_to_index_3d(gl_VertexIndex, uv3(frame_uniforms.voxel_grid_origin_resolution.w));

    DEBUG_Voxel_Visualizer_Geometry_In stage_out;
    stage_out.vertex_position = v4(uvw, 1);
    stage_out.color = textureLod(voxel_texture, v3(uvw) / frame_uniforms.voxel_grid_origin_resolution.w, 0);
    return stage_out;
}

geometry(Global_Layout) DEBUG_Voxel_Visualizer_Geometry_In[14] DEBUG_voxel_visualizer_geometry_shader(DEBUG_Voxel_Visualizer_Geometry_In stage_in[1])
{
    if (stage_in[0].color.a > 0)
    {
        DEBUG_Voxel_Visualizer_Geometry_In stage_out[14];
        for (u32 i = 0; i < 14; ++i)
        {
            stage_out[i].color = stage_in[0].color;
            stage_out[i].vertex_position.xyz = (gl_in[0].gl_Position.xyz / frame_uniforms.voxel_grid_origin_resolution.w * 2 - 1) * frame_uniforms.voxel_grid_origin_resolution.w;

            // NOTE: Cube vertex position from index
            stage_out[i].vertex_position.xyz += (v3((0x287A & (1 << i)) != 0, (0x02AF & (1 << i)) != 0, (0x31E3 & (1 << i)) != 0) - v3(0, 1, 0)) * 2;

            stage_out[i].vertex_position.xyz *= frame_uniforms.voxel_grid_origin_resolution.w * frame_uniforms.voxel_size / frame_uniforms.voxel_grid_origin_resolution.w;
            stage_out[i].vertex_position = frame_uniforms.view_projection * v4(stage_out[i].vertex_position.xyz + frame_uniforms.voxel_grid_origin_resolution.xyz, 1);
        }
        return stage_out;
    }
}

fragment(Global_Layout) DEBUG_Voxel_Visualizer_Fragment_Out DEBUG_voxel_visualizer_fragment_shader(DEBUG_Voxel_Visualizer_Geometry_In stage_in)
{
    DEBUG_Voxel_Visualizer_Fragment_Out stage_out = {v4(stage_in.color.rgb, 1)};
    return stage_out;
}

pipeline Clusterizer_Pipeline
{
    shaders = [clusterizer_shader];
};

pipeline Z_Prepass_Pipeline
{
    shaders = [depth_only_vertex_shader];

    rasterization_state = {
        cull_mode  = VK_CULL_MODE_FRONT_BIT,
        front_face = VK_FRONT_FACE_COUNTER_CLOCKWISE
    };

    depth_stencil_state = {
        depth_test_enable  = VK_TRUE,
        depth_write_enable = VK_TRUE,
        depth_compare_op   = VK_COMPARE_OP_GREATER_OR_EQUAL
    };
};

pipeline Update_Active_Clusters_Pipeline
{
    shaders = [full_screen_triangle_vertex_shader, update_active_clusters_shader];

    rasterization_state = {
        cull_mode  = VK_CULL_MODE_FRONT_BIT,
        front_face = VK_FRONT_FACE_COUNTER_CLOCKWISE
    };
};

pipeline Update_Unique_Clusters_Pipeline
{
    shaders = [update_unique_clusters_shader];
};

pipeline Cluster_Light_Culling_Pipeline
{
    shaders = [cluster_light_culling_shader];
};

pipeline Main_Pipeline
{
    shaders = [default_vertex_shader, default_fragment_shader];

    rasterization_state = {
        cull_mode  = VK_CULL_MODE_FRONT_BIT,
        front_face = VK_FRONT_FACE_COUNTER_CLOCKWISE
    };

    color_blend_state = [
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT}
    ];

    depth_stencil_state = {
        depth_test_enable  = VK_TRUE,
        depth_write_enable = VK_FALSE,
        depth_compare_op   = VK_COMPARE_OP_EQUAL
    };
};

pipeline Final_Pass_Pipeline
{
    shaders = [full_screen_triangle_vertex_shader, final_pass_fragment_shader];

    rasterization_state = {
        cull_mode  = VK_CULL_MODE_FRONT_BIT,
        front_face = VK_FRONT_FACE_COUNTER_CLOCKWISE
    };

    color_blend_state = [
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT}
    ];
};

pipeline Voxelizer_Pipeline
{
    shaders = [voxelizer_vertex_shader, voxelizer_geometry_shader, voxelizer_fragment_shader];
};

pipeline Voxelizer_Compute_Pipeline
{
    shaders = [voxelizer_compute_shader];
};

pipeline DEBUG_Cluster_Visualizer_Pipeline
{
    shaders = [DEBUG_cluster_visualizer_vertex_shader, DEBUG_cluster_visualizer_geometry_shader, DEBUG_voxel_visualizer_fragment_shader];

    input_assembly_state = {
        topology = VK_PRIMITIVE_TOPOLOGY_POINT_LIST
    };

    color_blend_state = [
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT}
    ];

    depth_stencil_state = {
        depth_test_enable  = VK_TRUE,
        depth_write_enable = VK_TRUE,
        depth_compare_op   = VK_COMPARE_OP_GREATER_OR_EQUAL
    };
};

pipeline DEBUG_Voxel_Visualizer_Pipeline
{
    shaders = [DEBUG_voxel_visualizer_vertex_shader, DEBUG_voxel_visualizer_geometry_shader, DEBUG_voxel_visualizer_fragment_shader];

    input_assembly_state = {
        topology = VK_PRIMITIVE_TOPOLOGY_POINT_LIST
    };

    color_blend_state = [
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT}
    ];

    depth_stencil_state = {
        depth_test_enable  = VK_TRUE,
        depth_write_enable = VK_TRUE,
        depth_compare_op   = VK_COMPARE_OP_GREATER_OR_EQUAL
    };
};