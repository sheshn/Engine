#version 450
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_samplerless_texture_functions : enable

#define s32 int
#define u32 uint
#define f32 float
#define f64 double

#define v2 vec2
#define v3 vec3
#define v4 vec4
#define uv2 uvec2
#define uv3 uvec3
#define sv2 ivec2
#define sv3 ivec3
#define m3x3 mat3
#define m4x4 mat4

struct Material
{
    v4  base_color_factor;
    f32 metallic_factor;
    f32 roughness_factor;

    u32 albedo_texture_id;
    u32 normal_texture_id;
    u32 roughness_metallic_occlusion_texture_id;

    u32 reserved[7];
};

struct Transform
{
    m4x4 model;
};

struct Voxel_Data
{
    u32 color;
};

struct Frame_Uniforms
{
    m4x4 view_projection;

    v3  voxel_grid_origin;
    f32 voxel_grid_resolution;
    f32 voxel_size;
};

u32 index_3d_to_index_1d(uv3 index_3d, uv3 dimension)
{
    return (index_3d.z * dimension.x * dimension.y) + (index_3d.y * dimension.x) + index_3d.x;
}

uv3 index_1d_to_index_3d(u32 index, uv3 dimension)
{
    u32 z = index / (dimension.x * dimension.y);
    index -= (z * dimension.x * dimension.y);
    return uv3(index % dimension.x, index / dimension.y, z);
}

u32 encode_v4_color_as_u32(v4 color)
{
    // TODO: Tune this value
    f32 hdr_range = 10;
    f32 hdr = length(color.rgb);
    color.rgb /= hdr;

    uv3 c = uv3(color.rgb * 255.0);
    u32 h = u32(clamp(hdr / hdr_range, 0, 1) * 127.0);
    u32 a = color.a > 0 ? 1 : 0;

    return (h << 24) | (c.r << 16) | (c.g << 8) | (c.b) | (a << 31);
}

v4 decode_u32_color_as_v4(u32 color)
{
    // TODO: Tune this value
    f32 hdr_range = 10;
    f32 hdr = ((color >> 24) & 0x0000007F) / 127.0;

    v4 result = v4((color >> 16) & 0x000000FF, (color >> 8) & 0X000000FF, color & 0X000000FF, (color >> 31) & 0x00000001);
    result.rgb *= hdr * hdr_range / 255.0;
    return result;
}

layout Default_Vertex_Layout
{
    layout(set = 0, binding = 3) buffer transform_buffer { Transform xforms[]; };
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) in uv2 in_instance_data;
    layout(location = 1) in v3 in_position;
    layout(location = 2) in v3 in_normal;
    layout(location = 3) in v2 in_uv0;

    layout(location = 0) flat out uv2 out_instance_data;
    layout(location = 1) out v3 out_normal;
    layout(location = 2) out v2 out_uv0;
};

vertex(Default_Vertex_Layout) void default_vertex_shader()
{
    Transform xform = xforms[in_instance_data.x];
    gl_Position = frame_uniforms.view_projection * xform.model * v4(in_position.xyz, 1.0);

    out_instance_data = in_instance_data;
    out_normal = in_normal;
    out_uv0 = in_uv0;
}

layout Default_Fragment_Layout
{
    layout(set = 0, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 0, binding = 1) uniform texture2D textures_2d[];
    layout(set = 0, binding = 2) buffer material_buffer { Material materials[]; };
    layout(set = 0, binding = 3) buffer transform_buffer { Transform xforms[]; };
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) flat in uv2 in_instance_data;
    layout(location = 1) in v3 in_normal;
    layout(location = 2) in v2 in_uv0;

    layout(location = 0) out v4 out_uv_coordinates;
    layout(location = 1) out v4 out_uv_gradients;
    layout(location = 2) out u32 out_material_id;
};

fragment(Default_Fragment_Layout) void default_fragment_shader()
{
    out_uv_coordinates = v4(fract(in_uv0).xy, 1, 1);
    out_uv_gradients = v4(dFdxFine(in_uv0), dFdyFine(in_uv0));
    out_material_id = in_instance_data.y;
}

layout Default_Compute_Layout
{
    layout (local_size_x = 8, local_size_y = 8) in;

    layout(set = 0, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 0, binding = 1) uniform texture2D textures_2d[];
    layout(set = 0, binding = 2) buffer material_buffer { Material materials[]; };

    layout(set = 1, binding = 0, rgba16) uniform image2D main_color_texture;
    layout(set = 1, binding = 1) uniform texture2D uv_coordinates_attachment;
    layout(set = 1, binding = 2) uniform texture2D uv_gradients_attachment;
    layout(set = 1, binding = 3) uniform utexture2D material_id_attachment;
};

compute(Default_Compute_Layout) void default_compute_shader()
{
    sv2 pixel_location = sv2(gl_GlobalInvocationID.xy);

    u32 material_id = u32(texelFetch(material_id_attachment, pixel_location, 0).r);
    v2 uv0 = texelFetch(uv_coordinates_attachment, pixel_location, 0).xy;
    v4 dxdy = texelFetch(uv_gradients_attachment, pixel_location, 0);

    // TODO: Implement voxel cone tracing!
    Material material = materials[material_id];
    v4 out_color = textureGrad(sampler2D(textures_2d[nonuniformEXT(material.albedo_texture_id)], texture_2d_sampler), uv0, dxdy.xy, dxdy.zw) * material.base_color_factor;

    imageStore(main_color_texture, pixel_location, out_color);
}

layout Final_Pass_Vertex_Layout
{
    layout(location = 0) out v2 out_uv;
};

vertex(Final_Pass_Vertex_Layout) void final_pass_vertex_shader()
{
    out_uv = v2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
    gl_Position = v4(out_uv * 2.0 - 1.0, 0, 1.0);
}

layout Final_Pass_Fragment_Layout
{
    layout(set = 0, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 0, binding = 1) uniform texture2D color0_attachment;

    layout(location = 0) in v2 in_uv;

    layout(location = 0) out v4 out_color;
};

fragment(Final_Pass_Fragment_Layout) void final_pass_fragment_shader()
{
    // TODO: Tonemap!
    out_color = texture(sampler2D(color0_attachment, texture_2d_sampler), in_uv);
}

vertex(Default_Vertex_Layout) void voxelizer_vertex_shader()
{
    Transform xform = xforms[in_instance_data.x];
    gl_Position = xform.model * v4(in_position.xyz, 1.0);

    out_instance_data = in_instance_data;
    out_normal = normalize(m3x3(xform.model) * in_normal);
    out_uv0 = in_uv0;
}

layout Voxelizer_Geometry_Layout
{
    layout(triangles) in;
    layout(triangle_strip, max_vertices = 3) out;

    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) flat in uv2 in_instance_data[];
    layout(location = 1) in v3 in_normal[];
    layout(location = 2) in v2 in_uv0[];

    layout(location = 0) flat out uv2 out_instance_data;
    layout(location = 1) out v3 out_position;
    layout(location = 2) out v3 out_normal;
    layout(location = 3) out v2 out_uv0;
};

geometry(Voxelizer_Geometry_Layout) void voxelizer_geometry_shader()
{
    v3 normal = abs(in_normal[0] + in_normal[1] + in_normal[2]);
    u32 max_index = normal.y > normal.x ? 1 : 0;
    max_index = normal.z > normal[max_index] ? 2 : max_index;

    v3 positions[3];
    for (u32 i = 0; i < 3; ++i)
    {
        positions[i] = (gl_in[i].gl_Position.xyz - frame_uniforms.voxel_grid_origin) / frame_uniforms.voxel_size;
        if (max_index == 0)
        {
            positions[i].xyz = positions[i].zyx;
        }
        else if (max_index == 1)
        {
            positions[i].xyz = positions[i].xzy;
        }
    }

    // NOTE: Enlarge triangle to achieve conservative rasterization
    v2 s0 = normalize(positions[1].xy - positions[0].xy);
    v2 s1 = normalize(positions[2].xy - positions[1].xy);
    v2 s2 = normalize(positions[0].xy - positions[2].xy);
    positions[0].xy += normalize(s2 - s0);
    positions[1].xy += normalize(s0 - s1);
    positions[2].xy += normalize(s1 - s2);

    for (u32 i = 0; i < 3; ++i)
    {
        out_instance_data = in_instance_data[i];
        out_position = gl_in[i].gl_Position.xyz;
        out_normal = in_normal[i];
        out_uv0 = in_uv0[i];

        gl_Position = v4(positions[i].xy / frame_uniforms.voxel_grid_resolution, 1, 1);
        EmitVertex();
    }
    EndPrimitive();
}

layout Voxelizer_Fragment_Layout
{
    layout(set = 0, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 0, binding = 1) uniform texture2D textures_2d[];
    layout(set = 0, binding = 2) buffer material_buffer { Material materials[]; };
    layout(set = 0, binding = 3) buffer transform_buffer { Transform xforms[]; };
    layout(set = 0, binding = 4) buffer voxel_buffer { Voxel_Data voxels[]; };
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) flat in uv2 in_instance_data;
    layout(location = 1) in v3 in_position;
    layout(location = 2) in v3 in_normal;
    layout(location = 3) in v2 in_uv0;
};

fragment(Voxelizer_Fragment_Layout) void voxelizer_fragment_shader()
{
    v3 uvw = v3(0.5) * ((in_position - frame_uniforms.voxel_grid_origin) / frame_uniforms.voxel_grid_resolution / frame_uniforms.voxel_size) + 0.5f;
    if (uvw == clamp(uvw, 0, 1))
    {
        Material material = materials[in_instance_data.y];
        v4 color = texture(sampler2D(textures_2d[material.albedo_texture_id], texture_2d_sampler), in_uv0) * material.base_color_factor;
        u32 encoded_color = encode_v4_color_as_u32(color);

        u32 index = index_3d_to_index_1d(uv3(floor(uvw * frame_uniforms.voxel_grid_resolution)), uv3(frame_uniforms.voxel_grid_resolution));
        atomicMax(voxels[index].color, encoded_color);
    }
}

layout Voxelizer_Compute_Layout
{
    layout (local_size_x = 256) in;

    layout(set = 0, binding = 4) buffer voxel_buffer { Voxel_Data voxels[]; };
    layout(set = 0, binding = 5, rgba8) uniform image3D voxel_texture;
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };
};

compute(Voxelizer_Compute_Layout) void voxelizer_compute_shader()
{
    uv3 uvw = index_1d_to_index_3d(gl_GlobalInvocationID.x, uv3(frame_uniforms.voxel_grid_resolution));
    v4 color = decode_u32_color_as_v4(voxels[gl_GlobalInvocationID.x].color);

    if (color.a > 0)
    {
        // TODO: Smooth from prevous data if the voxel grid origin moved?
        imageStore(voxel_texture, sv3(uvw), color);
    }
    else
    {
        imageStore(voxel_texture, sv3(uvw), v4(0));
    }

    voxels[gl_GlobalInvocationID.x].color = 0;
}

layout DEBUG_Voxel_Visualizer_Vertex_Layout
{
    layout(set = 0, binding = 6) uniform sampler3D voxel_texture;
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) out v4 out_color;
};

vertex(DEBUG_Voxel_Visualizer_Vertex_Layout) void DEBUG_voxel_visualizer_vertex_shader()
{
    uv3 uvw = index_1d_to_index_3d(gl_VertexIndex, uv3(frame_uniforms.voxel_grid_resolution));
    gl_Position = v4(uvw, 1);

    out_color = textureLod(voxel_texture, v3(uvw) / frame_uniforms.voxel_grid_resolution, 0);
}

layout DEBUG_Voxel_Visualizer_Geometry_Layout
{
    layout(points) in;
    layout(triangle_strip, max_vertices = 14) out;

    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) in v4 in_color[];

    layout(location = 0) out v4 out_color;
};

geometry(DEBUG_Voxel_Visualizer_Geometry_Layout) void DEBUG_voxel_visualizer_geometry_shader()
{
    if (in_color[0].a > 0)
    {
        for (u32 i = 0; i < 14; ++i)
        {
            out_color = in_color[0];

            gl_Position.xyz = (gl_in[0].gl_Position.xyz / frame_uniforms.voxel_grid_resolution * 2 - 1) * frame_uniforms.voxel_grid_resolution;

            // NOTE: Cube vertex position from index
            gl_Position.xyz += (v3((0x287A & (1 << i)) != 0, (0x02AF & (1 << i)) != 0, (0x31E3 & (1 << i)) != 0) - v3(0, 1, 0)) * 2;

            gl_Position.xyz *= frame_uniforms.voxel_grid_resolution * frame_uniforms.voxel_size / frame_uniforms.voxel_grid_resolution;
            gl_Position = frame_uniforms.view_projection * v4(gl_Position.xyz + frame_uniforms.voxel_grid_origin, 1);

            EmitVertex();
        }
        EndPrimitive();
    }
}

layout DEBUG_Voxel_Visualizer_Fragment_Layout
{
    layout(location = 0) in v4 in_color;

    layout(location = 0) out v4 out_color;
};

fragment(DEBUG_Voxel_Visualizer_Fragment_Layout) void DEBUG_voxel_visualizer_fragment_shader()
{
    out_color = v4(in_color.rgb, 1);
}