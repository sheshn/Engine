#version 450
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_samplerless_texture_functions : enable

#define s32 int
#define u32 uint
#define f32 float
#define f64 double

#define v2 vec2
#define v3 vec3
#define v4 vec4
#define quat v4
#define uv2 uvec2
#define uv3 uvec3
#define sv2 ivec2
#define sv3 ivec3
#define m3x3 mat3
#define m4x4 mat4

#define PI 3.14159265358979323846

#define INVALID_MATERIAL_ID (1 << 15)

struct Material
{
    v4  base_color_factor;
    f32 metallic_factor;
    f32 roughness_factor;

    u32 albedo_texture_id;
    u32 normal_texture_id;
    u32 occlusion_roughness_metallic_texture_id;

    u32 reserved[7];
};

struct Transform
{
    m4x4 model;
};

struct Voxel_Data
{
    u32 color;
};

struct Frame_Uniforms
{
    m4x4 projection;
    m4x4 view_projection;
    m4x4 inverse_view_projection;

    v3  voxel_grid_origin;
    f32 voxel_grid_resolution;
    f32 voxel_size;
    f32 voxel_ray_step_size;

    v2  inverse_render_dimensions;
};

u32 index_3d_to_index_1d(uv3 index_3d, uv3 dimension)
{
    return (index_3d.z * dimension.x * dimension.y) + (index_3d.y * dimension.x) + index_3d.x;
}

uv3 index_1d_to_index_3d(u32 index, uv3 dimension)
{
    u32 z = index / (dimension.x * dimension.y);
    index -= (z * dimension.x * dimension.y);
    return uv3(index % dimension.x, index / dimension.y, z);
}

u32 encode_v4_color_as_u32(v4 color)
{
    // TODO: Tune this value
    f32 hdr_range = 10;
    f32 hdr = length(color.rgb);
    color.rgb /= hdr;

    uv3 c = uv3(color.rgb * 255.0);
    u32 h = u32(clamp(hdr / hdr_range, 0, 1) * 127.0);
    u32 a = color.a > 0 ? 1 : 0;

    return (h << 24) | (c.r << 16) | (c.g << 8) | (c.b) | (a << 31);
}

v4 decode_u32_color_as_v4(u32 color)
{
    // TODO: Tune this value
    f32 hdr_range = 10;
    f32 hdr = ((color >> 24) & 0x0000007F) / 127.0;

    v4 result = v4((color >> 16) & 0x000000FF, (color >> 8) & 0X000000FF, color & 0X000000FF, (color >> 31) & 0x00000001);
    result.rgb *= hdr * hdr_range / 255.0;
    return result;
}

v3 depth_to_position(f32 depth, v2 uv, m4x4 projection, m4x4 inverse_view_projection)
{
    f32 linear_depth = projection[3][2] / (depth - projection[2][2]);
    v4 clip_space = v4(uv * 2 - 1, depth, 1);
    v4 world_space = inverse_view_projection * clip_space;
    return world_space.xyz / world_space.w;
}

layout Default_Vertex_Layout
{
    layout(set = 0, binding = 3) buffer transform_buffer { Transform xforms[]; };
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) in uv2 in_instance_data;
    layout(location = 1) in v3 in_position;
    layout(location = 2) in v3 in_normal;
    layout(location = 3) in v4 in_tangent;
    layout(location = 4) in v2 in_uv0;

    layout(location = 0) flat out u32 out_material_id;
    layout(location = 1) out v3 out_normal;
    layout(location = 2) out v3 out_tangent;
    layout(location = 3) out v3 out_bitangent;
    layout(location = 4) out v2 out_uv0;
};

vertex(Default_Vertex_Layout) void default_vertex_shader()
{
    Transform xform = xforms[in_instance_data.x];
    gl_Position = frame_uniforms.view_projection * xform.model * v4(in_position.xyz, 1.0);

    out_material_id = in_instance_data.y & 0x7FFF;
    if (in_tangent.w == -1)
    {
        out_material_id |= (1 << 15);
    }

    out_normal = normalize(m3x3(xform.model) * in_normal);
    out_tangent = normalize(m3x3(xform.model) * in_tangent.xyz);
    out_bitangent = cross(out_normal, out_tangent) * in_tangent.w;
    out_uv0 = in_uv0;
}

layout Default_Fragment_Layout
{
    layout(set = 0, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 0, binding = 1) uniform texture2D textures_2d[];
    layout(set = 0, binding = 2) buffer material_buffer { Material materials[]; };
    layout(set = 0, binding = 3) buffer transform_buffer { Transform xforms[]; };
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) flat in u32 in_material_id;
    layout(location = 1) in v3 in_normal;
    layout(location = 2) in v3 in_tangent;
    layout(location = 3) in v3 in_bitangent;
    layout(location = 4) in v2 in_uv0;

    layout(location = 0) out v4 out_uv_coordinates;
    layout(location = 1) out v4 out_uv_gradients;
    layout(location = 2) out v4 out_tangent_frame;
    layout(location = 3) out u32 out_material_id;
};

fragment(Default_Fragment_Layout) void default_fragment_shader()
{
    // TODO: Pack tangent frame as quaternion properly
    v3 normal = normalize(in_normal);
    v3 tangent = normalize(in_tangent);
    v3 bitangent = normalize(in_bitangent);
    out_tangent_frame = v4(tangent, 1);

    out_uv_coordinates = v4(fract(in_uv0), in_normal.xy);
    out_uv_gradients = v4(dFdxFine(in_uv0), dFdyFine(in_uv0));
    out_material_id = in_material_id;
}

layout Default_Compute_Layout
{
    layout (local_size_x = 8, local_size_y = 8) in;

    layout(set = 0, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 0, binding = 1) uniform texture2D textures_2d[];
    layout(set = 0, binding = 2) buffer material_buffer { Material materials[]; };
    layout(set = 0, binding = 6) uniform sampler3D voxel_texture;
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(set = 2, binding = 0, rgba16) uniform image2D main_color_texture;
    layout(set = 2, binding = 1) uniform texture2D uv_coordinates_attachment;
    layout(set = 2, binding = 2) uniform texture2D uv_gradients_attachment;
    layout(set = 2, binding = 3) uniform texture2D tangent_frame_attachment;
    layout(set = 2, binding = 4) uniform utexture2D material_id_attachment;
    layout(set = 2, binding = 5) uniform texture2D depth_attachment;
};

#define MAX_DIFFUSE_CONES 6
v3 diffuse_cone_directions[MAX_DIFFUSE_CONES] =
{
    v3(0.0f, 1.0f, 0.0f),
    v3(0.0f, 0.5f, 0.866025f),
    v3(0.823639f, 0.5f, 0.267617f),
    v3(0.509037f, 0.5f, -0.7006629f),
    v3(-0.50937f, 0.5f, -0.7006629f),
    v3(-0.823639f, 0.5f, 0.267617f)
};

f32 diffuse_cone_weights[] =
{
    PI / 4.0f,
    3.0f * PI / 20.0f,
    3.0f * PI / 20.0f,
    3.0f * PI / 20.0f,
    3.0f * PI / 20.0f,
    3.0f * PI / 20.0f,
};

v4 trace_cone(Frame_Uniforms frame_uniforms, sampler3D voxel_texture, v3 position, v3 normal, v3 cone_direction, f32 cone_aperture)
{
    // NOTE: Offset by one voxel to avoid self lighting
    f32 distance = frame_uniforms.voxel_size;
    v3 cone_origin = position + normal * distance;

    v4 samples = v4(0);
    f32 occlusion = 0;

    // TODO: Pass as uniforms?
    f32 max_distance = 1;
    f32 ao_falloff = 60;

    while (samples.a < 1 && distance <= max_distance)
    {
        f32 cone_diameter = 2 * cone_aperture * distance;
        f32 mip = log2(cone_diameter / frame_uniforms.voxel_size);

        v3 uvw = 0.5 * (((cone_origin + cone_direction * distance) - frame_uniforms.voxel_grid_origin) / frame_uniforms.voxel_size / frame_uniforms.voxel_grid_resolution) + 0.5;
        if (uvw != clamp(uvw, 0, 1) || mip >= 9) // TODO: Pass voxel_texture mipmap count as uniform
        {
            break;
        }

        v4 voxel_color = textureLod(voxel_texture, uvw, mip);
        samples += (1 - samples.a) * voxel_color;
        occlusion += ((1 - occlusion) * voxel_color.a) / (1 + ao_falloff * cone_diameter);

        distance += cone_diameter * frame_uniforms.voxel_ray_step_size;
    }

    return v4(samples.rgb, occlusion);
}

v4 calculate_indirect_lighting(Frame_Uniforms frame_uniforms, sampler3D voxel_texture, v3 position, v3 normal, v3 albedo, v3 specular, f32 roughness)
{
    v4 indirect_specular = v4(0);
    if (specular != v3(0))
    {
        v3 view_direction = normalize(frame_uniforms.voxel_grid_origin - position);
        v3 cone_direction = normalize(reflect(-view_direction, normal));
        f32 cone_aperture = clamp(tan(PI * 0.5 * roughness), 0.0174533f, PI);

        indirect_specular = trace_cone(frame_uniforms, voxel_texture, position, normal, cone_direction, cone_aperture);
        indirect_specular.rgb *= specular;
    }

    v4 indirect_diffuse = v4(0);
    if (albedo != v3(0))
    {
        v3 guide = v3(0, 1, 0);
        if (abs(dot(normal, guide)) == 1)
        {
            guide = v3(0, 0, 1);
        }
        v3 right = normalize(guide - dot(normal, guide) * normal);
        v3 up = cross(right, normal);

        for (u32 i = 0; i < MAX_DIFFUSE_CONES; ++i)
        {
            v3 cone_direction = normalize(normal + diffuse_cone_directions[i].x * right + diffuse_cone_directions[i].z * up);
            f32 cone_aperture = 0.57735;
            indirect_diffuse += trace_cone(frame_uniforms, voxel_texture, position, normal, cone_direction, cone_aperture) * diffuse_cone_weights[i];
        }

        indirect_diffuse.rgb *= albedo;
    }

    v3 result = indirect_diffuse.rgb + indirect_specular.rgb;
    return v4(result, clamp(1 - indirect_diffuse.a, 0, 1));
}

compute(Default_Compute_Layout) void default_compute_shader()
{
    sv2 pixel_location = sv2(gl_GlobalInvocationID.xy);

    u32 material_id = u32(texelFetch(material_id_attachment, pixel_location, 0).r) & 0x7FFF;
    if (material_id != INVALID_MATERIAL_ID)
    {
        v4 uv_coordinates_attachment_color = texelFetch(uv_coordinates_attachment, pixel_location, 0);
        v2 uv0 = uv_coordinates_attachment_color.xy;
        v4 dxdy = texelFetch(uv_gradients_attachment, pixel_location, 0);

        // TODO: Pack tangent frame as quaternion properly
        f32 tangent_frame_handedness = bool(material_id & (1 << 15)) ? -1.0f : 1.0f;
        v3 tangent_frame_normal;
        tangent_frame_normal.xy = uv_coordinates_attachment_color.zw;
        tangent_frame_normal.z = sqrt(1 - clamp(uv_coordinates_attachment_color.z * uv_coordinates_attachment_color.z + uv_coordinates_attachment_color.w * uv_coordinates_attachment_color.w, 0, 1));
        v3 tangent_frame_tangent = texelFetch(tangent_frame_attachment, pixel_location, 0).xyz;
        v3 tangent_frame_bitangent = cross(tangent_frame_normal, tangent_frame_tangent) * tangent_frame_handedness;
        m3x3 tangent_frame_matrix = m3x3(tangent_frame_tangent, tangent_frame_bitangent, tangent_frame_normal);

        f32 depth = texelFetch(depth_attachment, pixel_location, 0).x;
        v2 screen_uv = (pixel_location + 0.5f) * frame_uniforms.inverse_render_dimensions;
        v3 world_space_position = depth_to_position(depth, screen_uv, frame_uniforms.projection, frame_uniforms.inverse_view_projection);

        Material material = materials[material_id];
        v4 base_color = textureGrad(sampler2D(textures_2d[nonuniformEXT(material.albedo_texture_id)], texture_2d_sampler), uv0, dxdy.xy, dxdy.zw) * material.base_color_factor;
        v4 occlusion_roughness_metallic = textureGrad(sampler2D(textures_2d[nonuniformEXT(material.occlusion_roughness_metallic_texture_id)], texture_2d_sampler), uv0, dxdy.xy, dxdy.zw);
        f32 roughness = occlusion_roughness_metallic.y * material.roughness_factor;
        f32 metallic = occlusion_roughness_metallic.z * material.metallic_factor;

        v3 f0 = v3(0.04);
        v3 albedo = base_color.rgb * (v3(1) - f0);
        albedo *= 1 - metallic;

        roughness *= roughness;
        v3 specular = mix(f0, base_color.rgb, metallic);

        v2 normal = textureGrad(sampler2D(textures_2d[nonuniformEXT(material.normal_texture_id)], texture_2d_sampler), uv0, dxdy.xy, dxdy.zw).xy;
        v3 tangent_space_normal;
        tangent_space_normal.xy = normal * 2 - 1;
        tangent_space_normal.z = sqrt(1 - clamp(tangent_space_normal.x * tangent_space_normal.x + tangent_space_normal.y * tangent_space_normal.y, 0, 1));
        v3 world_space_normal = normalize(tangent_frame_matrix * tangent_space_normal);

        v4 indirect_lighting = calculate_indirect_lighting(frame_uniforms, voxel_texture, world_space_position, world_space_normal, albedo, specular, roughness);
        v4 out_color = v4(indirect_lighting.rgb * indirect_lighting.a, 1);

        imageStore(main_color_texture, pixel_location, out_color);
    }
}

layout Final_Pass_Vertex_Layout
{
    layout(location = 0) out v2 out_uv;
};

vertex(Final_Pass_Vertex_Layout) void final_pass_vertex_shader()
{
    out_uv = v2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
    gl_Position = v4(out_uv * 2.0 - 1.0, 0, 1.0);
}

layout Final_Pass_Fragment_Layout
{
    layout(set = 0, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 0, binding = 1) uniform texture2D color0_attachment;

    layout(location = 0) in v2 in_uv;

    layout(location = 0) out v4 out_color;
};

v3 aces_tonemap(v3 color)
{
    m3x3 aces_input_mat =
    {
        {0.59719, 0.35458, 0.04823},
        {0.07600, 0.90834, 0.01566},
        {0.02840, 0.13383, 0.83777}
    };
    m3x3 aces_output_mat =
    {
        { 1.60475, -0.53108, -0.07367},
        {-0.10208,  1.10813, -0.00605},
        {-0.00327, -0.07276,  1.07602}
    };

    color = color * aces_input_mat;
    color = ((color * (color + 0.0245786f) - 0.000090537f) / (color * (0.983729f * color + 0.4329510f) + 0.238081f)) * aces_output_mat;
    return clamp(color, 0, 1);
}

fragment(Final_Pass_Fragment_Layout) void final_pass_fragment_shader()
{
    v3 color = texture(sampler2D(color0_attachment, texture_2d_sampler), in_uv).xyz;
    color *= 3; // TODO: Automatic exposure

    color = aces_tonemap(color);

    out_color = v4(color, 1);
}

layout Voxelizer_Vertex_Layout
{
    layout(set = 0, binding = 3) buffer transform_buffer { Transform xforms[]; };
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) in uv2 in_instance_data;
    layout(location = 1) in v3 in_position;
    layout(location = 2) in v3 in_normal;
    layout(location = 3) in v4 in_tangent;
    layout(location = 4) in v2 in_uv0;

    layout(location = 0) flat out uv2 out_instance_data;
    layout(location = 1) out v3 out_normal;
    layout(location = 2) out v2 out_uv0;
};

vertex(Voxelizer_Vertex_Layout) void voxelizer_vertex_shader()
{
    Transform xform = xforms[in_instance_data.x];
    gl_Position = xform.model * v4(in_position.xyz, 1.0);

    out_instance_data = in_instance_data;
    out_normal = normalize(m3x3(xform.model) * in_normal);
    out_uv0 = in_uv0;
}

layout Voxelizer_Geometry_Layout
{
    layout(triangles) in;
    layout(triangle_strip, max_vertices = 3) out;

    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) flat in uv2 in_instance_data[];
    layout(location = 1) in v3 in_normal[];
    layout(location = 2) in v2 in_uv0[];

    layout(location = 0) flat out uv2 out_instance_data;
    layout(location = 1) out v3 out_position;
    layout(location = 2) out v3 out_normal;
    layout(location = 3) out v2 out_uv0;
};

geometry(Voxelizer_Geometry_Layout) void voxelizer_geometry_shader()
{
    v3 normal = abs(in_normal[0] + in_normal[1] + in_normal[2]);
    u32 max_index = normal.y > normal.x ? 1 : 0;
    max_index = normal.z > normal[max_index] ? 2 : max_index;

    v3 positions[3];
    for (u32 i = 0; i < 3; ++i)
    {
        positions[i] = (gl_in[i].gl_Position.xyz - frame_uniforms.voxel_grid_origin) / frame_uniforms.voxel_size;
        if (max_index == 0)
        {
            positions[i].xyz = positions[i].zyx;
        }
        else if (max_index == 1)
        {
            positions[i].xyz = positions[i].xzy;
        }
    }

    // NOTE: Enlarge triangle to achieve conservative rasterization
    v2 s0 = normalize(positions[1].xy - positions[0].xy);
    v2 s1 = normalize(positions[2].xy - positions[1].xy);
    v2 s2 = normalize(positions[0].xy - positions[2].xy);
    positions[0].xy += normalize(s2 - s0);
    positions[1].xy += normalize(s0 - s1);
    positions[2].xy += normalize(s1 - s2);

    for (u32 i = 0; i < 3; ++i)
    {
        out_instance_data = in_instance_data[i];
        out_position = gl_in[i].gl_Position.xyz;
        out_normal = in_normal[i];
        out_uv0 = in_uv0[i];

        gl_Position = v4(positions[i].xy / frame_uniforms.voxel_grid_resolution, 1, 1);
        EmitVertex();
    }
    EndPrimitive();
}

layout Voxelizer_Fragment_Layout
{
    layout(set = 0, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 0, binding = 1) uniform texture2D textures_2d[];
    layout(set = 0, binding = 2) buffer material_buffer { Material materials[]; };
    layout(set = 0, binding = 3) buffer transform_buffer { Transform xforms[]; };
    layout(set = 0, binding = 4) buffer voxel_buffer { Voxel_Data voxels[]; };
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) flat in uv2 in_instance_data;
    layout(location = 1) in v3 in_position;
    layout(location = 2) in v3 in_normal;
    layout(location = 3) in v2 in_uv0;
};

fragment(Voxelizer_Fragment_Layout) void voxelizer_fragment_shader()
{
    v3 uvw = 0.5 * ((in_position - frame_uniforms.voxel_grid_origin) / frame_uniforms.voxel_grid_resolution / frame_uniforms.voxel_size) + 0.5f;
    if (uvw == clamp(uvw, 0, 1))
    {
        Material material = materials[in_instance_data.y];
        v4 color = texture(sampler2D(textures_2d[material.albedo_texture_id], texture_2d_sampler), in_uv0) * material.base_color_factor;
        u32 encoded_color = encode_v4_color_as_u32(color);

        u32 index = index_3d_to_index_1d(uv3(floor(uvw * frame_uniforms.voxel_grid_resolution)), uv3(frame_uniforms.voxel_grid_resolution));
        atomicMax(voxels[index].color, encoded_color);
    }
}

layout Voxelizer_Compute_Layout
{
    layout (local_size_x = 256) in;

    layout(set = 0, binding = 4) buffer voxel_buffer { Voxel_Data voxels[]; };
    layout(set = 0, binding = 5, rgba8) uniform image3D voxel_texture;
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };
};

compute(Voxelizer_Compute_Layout) void voxelizer_compute_shader()
{
    uv3 uvw = index_1d_to_index_3d(gl_GlobalInvocationID.x, uv3(frame_uniforms.voxel_grid_resolution));
    v4 color = decode_u32_color_as_v4(voxels[gl_GlobalInvocationID.x].color);

    if (color.a > 0)
    {
        // TODO: Smooth from prevous data if the voxel grid origin moved?
        imageStore(voxel_texture, sv3(uvw), color);
    }
    else
    {
        imageStore(voxel_texture, sv3(uvw), v4(0));
    }

    voxels[gl_GlobalInvocationID.x].color = 0;
}

layout DEBUG_Voxel_Visualizer_Vertex_Layout
{
    layout(set = 0, binding = 6) uniform sampler3D voxel_texture;
    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) out v4 out_color;
};

vertex(DEBUG_Voxel_Visualizer_Vertex_Layout) void DEBUG_voxel_visualizer_vertex_shader()
{
    uv3 uvw = index_1d_to_index_3d(gl_VertexIndex, uv3(frame_uniforms.voxel_grid_resolution));
    gl_Position = v4(uvw, 1);

    out_color = textureLod(voxel_texture, v3(uvw) / frame_uniforms.voxel_grid_resolution, 0);
}

layout DEBUG_Voxel_Visualizer_Geometry_Layout
{
    layout(points) in;
    layout(triangle_strip, max_vertices = 14) out;

    layout(set = 1, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(location = 0) in v4 in_color[];

    layout(location = 0) out v4 out_color;
};

geometry(DEBUG_Voxel_Visualizer_Geometry_Layout) void DEBUG_voxel_visualizer_geometry_shader()
{
    if (in_color[0].a > 0)
    {
        for (u32 i = 0; i < 14; ++i)
        {
            out_color = in_color[0];

            gl_Position.xyz = (gl_in[0].gl_Position.xyz / frame_uniforms.voxel_grid_resolution * 2 - 1) * frame_uniforms.voxel_grid_resolution;

            // NOTE: Cube vertex position from index
            gl_Position.xyz += (v3((0x287A & (1 << i)) != 0, (0x02AF & (1 << i)) != 0, (0x31E3 & (1 << i)) != 0) - v3(0, 1, 0)) * 2;

            gl_Position.xyz *= frame_uniforms.voxel_grid_resolution * frame_uniforms.voxel_size / frame_uniforms.voxel_grid_resolution;
            gl_Position = frame_uniforms.view_projection * v4(gl_Position.xyz + frame_uniforms.voxel_grid_origin, 1);

            EmitVertex();
        }
        EndPrimitive();
    }
}

layout DEBUG_Voxel_Visualizer_Fragment_Layout
{
    layout(location = 0) in v4 in_color;

    layout(location = 0) out v2 out_uv_coordinates;
    layout(location = 1) out v4 out_uv_gradients;
    layout(location = 2) out v4 out_tangent_frame;
    layout(location = 3) out u32 out_material_id;
};

fragment(DEBUG_Voxel_Visualizer_Fragment_Layout) void DEBUG_voxel_visualizer_fragment_shader()
{
    out_uv_coordinates = v2(0);
    out_tangent_frame = v4(0);
    out_material_id = 0;

    // NOTE: For this debug visualization we just put the color in the uv_gradients attachment.
    // We need to change the shading pass compute shader manually in order to see this.
    // TODO: Pass debug visualization as a uniform to the shading pass compute shader and output uv_gradients as the final color if it is set?
    out_uv_gradients = v4(in_color.rgb, 1);
}