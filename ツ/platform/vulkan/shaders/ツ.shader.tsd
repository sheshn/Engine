#define INVALID_MATERIAL_ID (1 << 15)

struct Material
{
    v4  base_color_factor;
    f32 metallic_factor;
    f32 roughness_factor;

    u32 albedo_texture_id;
    u32 normal_texture_id;
    u32 occlusion_roughness_metallic_texture_id;

    u32 reserved[7];
};

struct Transform
{
    m4x4 model;
};

struct Voxel_Data
{
    u32 color;
};

struct Frame_Uniforms
{
    m4x4 projection;
    m4x4 view_projection;
    m4x4 inverse_view_projection;

    v3  voxel_grid_origin;
    f32 voxel_grid_resolution;
    f32 voxel_size;
    f32 voxel_ray_step_size;

    v2  inverse_render_dimensions;
};

quat tangent_space_to_quat(v3 tangent, v3 bitangent, v3 normal)
{
    quat q;
    q.x = normal.y - bitangent.z;
    q.y = tangent.z - normal.x;
    q.z = bitangent.x - tangent.y;
    q.w = 1 + tangent.x + bitangent.y + normal.z;

    return normalize(q);
}

m3x3 quat_to_tangent_space(quat q)
{
    v3 tangent   = v3(1, 0, 0) + v3(-2,  2,  2) * q.y * q.yxw + v3(-2, -2,  2) * q.z * q.zwx;
    v3 bitangent = v3(0, 1, 0) + v3( 2, -2,  2) * q.z * q.wzy + v3( 2, -2, -2) * q.x * q.yxw;
    v3 normal    = v3(0, 0, 1) + v3( 2,  2, -2) * q.x * q.zwx + v3(-2,  2, -2) * q.y * q.wzy;

    return m3x3(tangent, bitangent, normal);
}

v3 depth_to_position(f32 depth, v2 uv, m4x4 projection, m4x4 inverse_view_projection)
{
    f32 linear_depth = projection[3][2] / (depth - projection[2][2]);
    v4 clip_space = v4(uv * 2 - 1, depth, 1);
    v4 world_space = inverse_view_projection * clip_space;
    return world_space.xyz / world_space.w;
}

layout Global_Layout
{
    layout(set = 0, binding = 0) uniform frame_uniform_buffer { Frame_Uniforms frame_uniforms; };

    layout(set = 1, binding = 0) uniform sampler texture_2d_sampler;
    layout(set = 1, binding = 1) uniform texture2D textures_2d[];
    layout(set = 1, binding = 2) buffer material_buffer { Material materials[]; };
    layout(set = 1, binding = 3) buffer transform_buffer { Transform xforms[]; };

    layout(set = 1, binding = 4, rgba16) uniform image2D main_color_image;
    layout(set = 1, binding = 5) uniform texture2D main_color_texture;
    layout(set = 1, binding = 6) uniform texture2D uv_coordinates_attachment;
    layout(set = 1, binding = 7) uniform texture2D uv_gradients_attachment;
    layout(set = 1, binding = 8) uniform texture2D tangent_frame_attachment;
    layout(set = 1, binding = 9) uniform utexture2D material_id_attachment;
    layout(set = 1, binding = 10) uniform texture2D depth_attachment;

    layout(set = 1, binding = 11) buffer voxel_buffer { Voxel_Data voxels[]; };
    layout(set = 1, binding = 12, rgba8) uniform image3D voxel_image;
    layout(set = 1, binding = 13) uniform sampler3D voxel_texture;
};

struct Default_Vertex_In
{
    uv2 instance_data: [per_instance];

    v3 position;
    v3 normal;
    v4 tangent;
    v2 uv0;
};

struct Default_Fragment_In
{
    v4 vertex_position: [position];

    u32 material_id: [flat];

    v3 normal;
    v3 tangent;
    v3 bitangent;
    v2 uv0;
};

struct Default_Fragment_Out
{
    v2  uv_coordinates;
    v4  uv_gradients;
    v4  tangent_frame;
    u32 material_id;
};

vertex(Global_Layout) Default_Fragment_In default_vertex_shader(Default_Vertex_In stage_in)
{
    Default_Fragment_In stage_out;
    stage_out.vertex_position = frame_uniforms.view_projection * xforms[stage_in.instance_data.x].model * v4(stage_in.position.xyz, 1.0);
    stage_out.material_id = stage_in.instance_data.y;
    stage_out.normal = normalize(m3x3(xforms[stage_in.instance_data.x].model) * stage_in.normal);
    stage_out.tangent = normalize(m3x3(xforms[stage_in.instance_data.x].model) * stage_in.tangent.xyz);
    stage_out.bitangent = cross(stage_out.normal, stage_out.tangent) * stage_in.tangent.w;
    stage_out.uv0 = stage_in.uv0;
    return stage_out;
}

fragment(Global_Layout) Default_Fragment_Out default_fragment_shader(Default_Fragment_In stage_in)
{
    v3 normal = normalize(stage_in.normal);
    v3 tangent = normalize(stage_in.tangent);
    v3 bitangent = normalize(stage_in.bitangent);

    Default_Fragment_Out stage_out =
    {
        fract(stage_in.uv0),
        v4(dFdxFine(stage_in.uv0), dFdyFine(stage_in.uv0)),
        tangent_space_to_quat(tangent, bitangent, normal),
        stage_in.material_id
    };
    return stage_out;
}

#define MAX_DIFFUSE_CONES 6
v3 diffuse_cone_directions[MAX_DIFFUSE_CONES] =
{
    v3(0.0f, 1.0f, 0.0f),
    v3(0.0f, 0.5f, 0.866025f),
    v3(0.823639f, 0.5f, 0.267617f),
    v3(0.509037f, 0.5f, -0.7006629f),
    v3(-0.50937f, 0.5f, -0.7006629f),
    v3(-0.823639f, 0.5f, 0.267617f)
};

f32 diffuse_cone_weights[] =
{
    PI / 4.0f,
    3.0f * PI / 20.0f,
    3.0f * PI / 20.0f,
    3.0f * PI / 20.0f,
    3.0f * PI / 20.0f,
    3.0f * PI / 20.0f,
};

v4 trace_cone(Frame_Uniforms frame_uniforms, sampler3D voxel_texture, v3 position, v3 normal, v3 cone_direction, f32 cone_aperture)
{
    // NOTE: Offset by one voxel to avoid self lighting
    f32 distance = frame_uniforms.voxel_size;
    v3 cone_origin = position + normal * distance;

    v4 samples = v4(0);
    f32 occlusion = 0;

    // TODO: Pass as uniforms?
    f32 max_distance = 1;
    f32 ao_falloff = 60;

    while (samples.a < 1 && distance <= max_distance)
    {
        f32 cone_diameter = 2 * cone_aperture * distance;
        f32 mip = log2(cone_diameter / frame_uniforms.voxel_size);

        v3 uvw = 0.5 * (((cone_origin + cone_direction * distance) - frame_uniforms.voxel_grid_origin) / frame_uniforms.voxel_size / frame_uniforms.voxel_grid_resolution) + 0.5;
        if (uvw != clamp(uvw, 0, 1) || mip >= 9) // TODO: Pass voxel_texture mipmap count as uniform
        {
            break;
        }

        v4 voxel_color = textureLod(voxel_texture, uvw, mip);
        samples += (1 - samples.a) * voxel_color;
        occlusion += ((1 - occlusion) * voxel_color.a) / (1 + ao_falloff * cone_diameter);

        distance += cone_diameter * frame_uniforms.voxel_ray_step_size;
    }

    return v4(samples.rgb, occlusion);
}

v4 calculate_indirect_lighting(Frame_Uniforms frame_uniforms, sampler3D voxel_texture, v3 position, v3 normal, v3 albedo, v3 specular, f32 roughness)
{
    v4 indirect_specular = v4(0);
    if (specular != v3(0))
    {
        v3 view_direction = normalize(frame_uniforms.voxel_grid_origin - position);
        v3 cone_direction = normalize(reflect(-view_direction, normal));
        f32 cone_aperture = clamp(tan(PI * 0.5 * roughness), 0.0174533f, PI);

        indirect_specular = trace_cone(frame_uniforms, voxel_texture, position, normal, cone_direction, cone_aperture);
        indirect_specular.rgb *= specular;
    }

    v4 indirect_diffuse = v4(0);
    if (albedo != v3(0))
    {
        v3 guide = v3(0, 1, 0);
        if (abs(dot(normal, guide)) == 1)
        {
            guide = v3(0, 0, 1);
        }
        v3 right = normalize(guide - dot(normal, guide) * normal);
        v3 up = cross(right, normal);

        for (u32 i = 0; i < MAX_DIFFUSE_CONES; ++i)
        {
            v3 cone_direction = normalize(normal + diffuse_cone_directions[i].x * right + diffuse_cone_directions[i].z * up);
            f32 cone_aperture = 0.57735;
            indirect_diffuse += trace_cone(frame_uniforms, voxel_texture, position, normal, cone_direction, cone_aperture) * diffuse_cone_weights[i];
        }

        indirect_diffuse.rgb *= albedo;
    }

    v3 result = indirect_diffuse.rgb + indirect_specular.rgb;
    return v4(result, clamp(1 - indirect_diffuse.a, 0, 1));
}

layout Default_Compute_Layout
{
    layout (local_size_x = 8, local_size_y = 8) in;
};

compute(Global_Layout, Default_Compute_Layout) void shading_compute_shader()
{
    sv2 pixel_location = sv2(gl_GlobalInvocationID.xy);

    u32 material_id = u32(texelFetch(material_id_attachment, pixel_location, 0).r);
    if (material_id != INVALID_MATERIAL_ID)
    {
        v2 uv0 = texelFetch(uv_coordinates_attachment, pixel_location, 0).xy;
        v4 dxdy = texelFetch(uv_gradients_attachment, pixel_location, 0);

        quat tangent_frame = texelFetch(tangent_frame_attachment, pixel_location, 0);
        m3x3 tangent_frame_matrix = quat_to_tangent_space(tangent_frame);

        f32 depth = texelFetch(depth_attachment, pixel_location, 0).x;
        v2 screen_uv = (pixel_location + 0.5f) * frame_uniforms.inverse_render_dimensions;
        v3 world_space_position = depth_to_position(depth, screen_uv, frame_uniforms.projection, frame_uniforms.inverse_view_projection);

        Material material = materials[material_id];
        v4 base_color = textureGrad(sampler2D(textures_2d[nonuniformEXT(material.albedo_texture_id)], texture_2d_sampler), uv0, dxdy.xy, dxdy.zw) * material.base_color_factor;
        v4 occlusion_roughness_metallic = textureGrad(sampler2D(textures_2d[nonuniformEXT(material.occlusion_roughness_metallic_texture_id)], texture_2d_sampler), uv0, dxdy.xy, dxdy.zw);
        f32 roughness = occlusion_roughness_metallic.y * material.roughness_factor;
        f32 metallic = occlusion_roughness_metallic.z * material.metallic_factor;

        v3 f0 = v3(0.04);
        v3 albedo = base_color.rgb * (v3(1) - f0);
        albedo *= 1 - metallic;

        roughness *= roughness;
        v3 specular = mix(f0, base_color.rgb, metallic);

        v2 normal = textureGrad(sampler2D(textures_2d[nonuniformEXT(material.normal_texture_id)], texture_2d_sampler), uv0, dxdy.xy, dxdy.zw).xy;
        v3 tangent_space_normal;
        tangent_space_normal.xy = normal * 2 - 1;
        tangent_space_normal.z = sqrt(1 - clamp(tangent_space_normal.x * tangent_space_normal.x + tangent_space_normal.y * tangent_space_normal.y, 0, 1));
        v3 world_space_normal = normalize(tangent_frame_matrix * tangent_space_normal);

        // v4 indirect_lighting = calculate_indirect_lighting(frame_uniforms, voxel_texture, world_space_position, world_space_normal, albedo, specular, roughness);
        // v4 out_color = v4(indirect_lighting.rgb * indirect_lighting.a, 1);

        v4 out_color = v4(albedo, 1);

        imageStore(main_color_image, pixel_location, out_color);
    }
}

struct Final_Pass_Fragment_In
{
    v4 vertex_position: [position];

    v2 uv;
};

struct Final_Pass_Fragment_Out
{
    v4 color;
};

vertex(Global_Layout) Final_Pass_Fragment_In final_pass_vertex_shader()
{
    Final_Pass_Fragment_In stage_out;
    stage_out.uv = v2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
    stage_out.vertex_position = v4(stage_out.uv * 2.0 - 1.0, 0, 1.0);
    return stage_out;
}

v3 aces_tonemap(v3 color)
{
    m3x3 aces_input_mat =
    {
        {0.59719, 0.35458, 0.04823},
        {0.07600, 0.90834, 0.01566},
        {0.02840, 0.13383, 0.83777}
    };
    m3x3 aces_output_mat =
    {
        { 1.60475, -0.53108, -0.07367},
        {-0.10208,  1.10813, -0.00605},
        {-0.00327, -0.07276,  1.07602}
    };

    color = color * aces_input_mat;
    color = ((color * (color + 0.0245786f) - 0.000090537f) / (color * (0.983729f * color + 0.4329510f) + 0.238081f)) * aces_output_mat;
    return clamp(color, 0, 1);
}

fragment(Global_Layout) Final_Pass_Fragment_Out final_pass_fragment_shader(Final_Pass_Fragment_In stage_in)
{
    v3 color = texture(sampler2D(main_color_texture, texture_2d_sampler), stage_in.uv).xyz;
    color *= 2; // TODO: Automatic exposure

    color = aces_tonemap(color);

    Final_Pass_Fragment_Out stage_out = {v4(color, 1)};
    return stage_out;
}

struct Voxelizer_Geometry_In
{
    v4 vertex_position: [position];

    u32 material_id: [flat];

    v3 normal;
    v2 uv0;
};

struct Voxelizer_Geometry_Out
{
    v4 vertex_position: [position];

    u32 material_id: [flat];

    v3 position;
    v3 normal;
    v2 uv0;
};

u32 index_3d_to_index_1d(uv3 index_3d, uv3 dimension)
{
    return (index_3d.z * dimension.x * dimension.y) + (index_3d.y * dimension.x) + index_3d.x;
}

uv3 index_1d_to_index_3d(u32 index, uv3 dimension)
{
    u32 z = index / (dimension.x * dimension.y);
    index -= (z * dimension.x * dimension.y);
    return uv3(index % dimension.x, index / dimension.y, z);
}

u32 encode_v4_color_as_u32(v4 color)
{
    // TODO: Tune this value
    f32 hdr_range = 10;
    f32 hdr = length(color.rgb);
    color.rgb /= hdr;

    uv3 c = uv3(color.rgb * 255.0);
    u32 h = u32(clamp(hdr / hdr_range, 0, 1) * 127.0);
    u32 a = color.a > 0 ? 1 : 0;

    return (h << 24) | (c.r << 16) | (c.g << 8) | (c.b) | (a << 31);
}

v4 decode_u32_color_as_v4(u32 color)
{
    // TODO: Tune this value
    f32 hdr_range = 10;
    f32 hdr = ((color >> 24) & 0x0000007F) / 127.0;

    v4 result = v4((color >> 16) & 0x000000FF, (color >> 8) & 0X000000FF, color & 0X000000FF, (color >> 31) & 0x00000001);
    result.rgb *= hdr * hdr_range / 255.0;
    return result;
}

vertex(Global_Layout) Voxelizer_Geometry_In voxelizer_vertex_shader(Default_Vertex_In stage_in)
{
    Voxelizer_Geometry_In stage_out;
    stage_out.vertex_position = xforms[stage_in.instance_data.x].model * v4(stage_in.position.xyz, 1.0);
    stage_out.material_id = stage_in.instance_data.y;
    stage_out.normal = normalize(m3x3(xforms[stage_in.instance_data.x].model) * stage_in.normal);
    stage_out.uv0 = stage_in.uv0;
    return stage_out;
}

geometry(Global_Layout) Voxelizer_Geometry_Out[3] voxelizer_geometry_shader(Voxelizer_Geometry_In stage_in[3])
{
    v3 normal = abs(stage_in[0].normal + stage_in[1].normal + stage_in[2].normal);
    u32 max_index = normal.y > normal.x ? 1 : 0;
    max_index = normal.z > normal[max_index] ? 2 : max_index;

    v3 positions[3];
    for (u32 i = 0; i < 3; ++i)
    {
        positions[i] = (gl_in[i].gl_Position.xyz - frame_uniforms.voxel_grid_origin) / frame_uniforms.voxel_size;
        if (max_index == 0)
        {
            positions[i].xyz = positions[i].zyx;
        }
        else if (max_index == 1)
        {
            positions[i].xyz = positions[i].xzy;
        }
    }

    // NOTE: Enlarge triangle to achieve conservative rasterization
    v2 s0 = normalize(positions[1].xy - positions[0].xy);
    v2 s1 = normalize(positions[2].xy - positions[1].xy);
    v2 s2 = normalize(positions[0].xy - positions[2].xy);
    positions[0].xy += normalize(s2 - s0);
    positions[1].xy += normalize(s0 - s1);
    positions[2].xy += normalize(s1 - s2);

    Voxelizer_Geometry_Out stage_out[3];
    for (u32 i = 0; i < 3; ++i)
    {
        stage_out[i].material_id = stage_in[i].material_id;
        stage_out[i].position = gl_in[i].gl_Position.xyz;
        stage_out[i].normal = stage_in[i].normal;
        stage_out[i].uv0 = stage_in[i].uv0;

        stage_out[i].vertex_position = v4(positions[i].xy / frame_uniforms.voxel_grid_resolution, 1, 1);
    }
    return stage_out;
}

fragment(Global_Layout) void voxelizer_fragment_shader(Voxelizer_Geometry_Out stage_in)
{
    v3 uvw = 0.5 * ((stage_in.position - frame_uniforms.voxel_grid_origin) / frame_uniforms.voxel_grid_resolution / frame_uniforms.voxel_size) + 0.5f;
    if (uvw == clamp(uvw, 0, 1))
    {
        Material material = materials[stage_in.material_id];
        v4 color = texture(sampler2D(textures_2d[material.albedo_texture_id], texture_2d_sampler), stage_in.uv0) * material.base_color_factor;
        u32 encoded_color = encode_v4_color_as_u32(color);

        u32 index = index_3d_to_index_1d(uv3(floor(uvw * frame_uniforms.voxel_grid_resolution)), uv3(frame_uniforms.voxel_grid_resolution));
        atomicMax(voxels[index].color, encoded_color);
    }
}

layout Voxelizer_Compute_Layout
{
    layout (local_size_x = 256) in;
};

compute(Global_Layout, Voxelizer_Compute_Layout) void voxelizer_compute_shader()
{
    uv3 uvw = index_1d_to_index_3d(gl_GlobalInvocationID.x, uv3(frame_uniforms.voxel_grid_resolution));
    v4 color = decode_u32_color_as_v4(voxels[gl_GlobalInvocationID.x].color);

    if (color.a > 0)
    {
        // TODO: Smooth from prevous data if the voxel grid origin moved?
        imageStore(voxel_image, sv3(uvw), color);
    }
    else
    {
        imageStore(voxel_image, sv3(uvw), v4(0));
    }

    voxels[gl_GlobalInvocationID.x].color = 0;
}

struct DEBUG_Voxel_Visualizer_Geometry_In
{
    v4 vertex_position: [position];

    v4 color;
};

struct DEBUG_Voxel_Visualizer_Fragment_Out
{
    v2  uv_coordinates;
    v4  uv_gradients;
    v4  tangent_frame;
    u32 material_id;
};

vertex(Global_Layout) DEBUG_Voxel_Visualizer_Geometry_In DEBUG_voxel_visualizer_vertex_shader()
{
    uv3 uvw = index_1d_to_index_3d(gl_VertexIndex, uv3(frame_uniforms.voxel_grid_resolution));

    DEBUG_Voxel_Visualizer_Geometry_In stage_out;
    stage_out.vertex_position = v4(uvw, 1);
    stage_out.color = textureLod(voxel_texture, v3(uvw) / frame_uniforms.voxel_grid_resolution, 0);
    return stage_out;
}

geometry(Global_Layout) DEBUG_Voxel_Visualizer_Geometry_In[14] DEBUG_voxel_visualizer_geometry_shader(DEBUG_Voxel_Visualizer_Geometry_In stage_in[1])
{
    if (stage_in[0].color.a > 0)
    {
        DEBUG_Voxel_Visualizer_Geometry_In stage_out[14];
        for (u32 i = 0; i < 14; ++i)
        {
            stage_out[i].color = stage_in[0].color;
            stage_out[i].vertex_position.xyz = (gl_in[0].gl_Position.xyz / frame_uniforms.voxel_grid_resolution * 2 - 1) * frame_uniforms.voxel_grid_resolution;

            // NOTE: Cube vertex position from index
            stage_out[i].vertex_position.xyz += (v3((0x287A & (1 << i)) != 0, (0x02AF & (1 << i)) != 0, (0x31E3 & (1 << i)) != 0) - v3(0, 1, 0)) * 2;

            stage_out[i].vertex_position.xyz *= frame_uniforms.voxel_grid_resolution * frame_uniforms.voxel_size / frame_uniforms.voxel_grid_resolution;
            stage_out[i].vertex_position = frame_uniforms.view_projection * v4(stage_out[i].vertex_position.xyz + frame_uniforms.voxel_grid_origin, 1);
        }
        return stage_out;
    }
}

fragment(Global_Layout) DEBUG_Voxel_Visualizer_Fragment_Out DEBUG_voxel_visualizer_fragment_shader(DEBUG_Voxel_Visualizer_Geometry_In stage_in)
{
    // NOTE: For this debug visualization we just put the color in the uv_gradients attachment.
    // We need to change the shading pass compute shader manually in order to see this.
    // TODO: Pass debug visualization as a uniform to the shading pass compute shader and output uv_gradients as the final color if it is set?
    DEBUG_Voxel_Visualizer_Fragment_Out stage_out =
    {
        v2(0),
        v4(in_color.rgb, 1),
        v4(0),
        0
    };
    return stage_out;
}


pipeline Gbuffer_Pipeline
{
    shaders = [default_vertex_shader, default_fragment_shader];

    rasterization_state = {
        cull_mode  = VK_CULL_MODE_FRONT_BIT,
        front_face = VK_FRONT_FACE_COUNTER_CLOCKWISE
    };

    color_blend_state = [
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT},
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT},
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT},
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT}
    ];

    depth_stencil_state = {
        depth_test_enable  = VK_TRUE,
        depth_write_enable = VK_TRUE,
        depth_compare_op   = VK_COMPARE_OP_GREATER_OR_EQUAL
    };
};

pipeline Shading_Compute_Pipeline
{
    shaders = [shading_compute_shader];
};

pipeline Final_Pass_Pipeline
{
    shaders = [final_pass_vertex_shader, final_pass_fragment_shader];

    rasterization_state = {
        cull_mode  = VK_CULL_MODE_FRONT_BIT,
        front_face = VK_FRONT_FACE_COUNTER_CLOCKWISE
    };

    color_blend_state = [
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT}
    ];
};

pipeline Voxelizer_Pipeline
{
    shaders = [voxelizer_vertex_shader, voxelizer_geometry_shader, voxelizer_fragment_shader];
};

pipeline Voxelizer_Compute_Pipeline
{
    shaders = [voxelizer_compute_shader];
};

pipeline DEBUG_Voxel_Visualizer_Pipeline
{
    shaders = [DEBUG_voxel_visualizer_vertex_shader, DEBUG_voxel_visualizer_geometry_shader, DEBUG_voxel_visualizer_fragment_shader];

    input_assembly_state = {
        topology = VK_PRIMITIVE_TOPOLOGY_POINT_LIST
    };

    color_blend_state = [
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT},
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT},
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT},
        {color_write_mask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT}
    ];
};